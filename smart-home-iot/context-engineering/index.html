<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="This skill should be used when the user asks">
  <title>context-engineering - OpenClaw Directory</title>
  <link rel="canonical" href="https://moltdirectory.com/smart-home-iot/context-engineering/">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ü¶û</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/style.css">
  <script>
    // Apply saved theme before page renders to prevent flash
    (function() {
      const savedTheme = localStorage.getItem('theme') || 'dark';
      if (savedTheme === 'light') {
        document.documentElement.setAttribute('data-theme', 'light');
      }
    })();
  </script>
</head>
<body>
  <header class="header">
    <div class="header-inner">
      <a href="/" class="logo">

        <span class="logo-text">OpenClaw Directory</span>
      </a>
      <nav class="header-links">
        <a href="/start-here/" class="header-link">Start Here</a>
        <a href="/security-auditor" class="header-link">Security Auditor</a>
        <a href="https://github.com/neonone123/moltdirectory/issues/new?template=add-skill.yml" class="header-link" target="_blank" rel="noopener">Add Skill</a>
        <button class="theme-toggle" aria-label="Toggle theme" onclick="toggleTheme()">
          <svg class="icon-moon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
          <svg class="icon-sun" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
        </button>
        <a href="https://www.reddit.com/r/OpenClawDirectory/" class="header-link" target="_blank" rel="noopener" aria-label="Community">
          <svg viewBox="0 0 16 16" fill="currentColor" width="28" height="28"><path d="M6.167 8a.83.83 0 0 0-.83.83c0 .459.372.84.83.831a.831.831 0 0 0 0-1.661m1.843 3.647c.315 0 1.403-.038 1.976-.611a.23.23 0 0 0 0-.306.213.213 0 0 0-.306 0c-.353.363-1.126.487-1.67.487-.545 0-1.308-.124-1.671-.487a.213.213 0 0 0-.306 0 .213.213 0 0 0 0 .306c.564.563 1.652.61 1.977.61zm.992-2.807c0 .458.373.83.831.83s.83-.381.83-.83a.831.831 0 0 0-1.66 0z"/><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0m-3.828-1.165c-.315 0-.602.124-.812.325-.801-.573-1.9-.945-3.121-.993l.534-2.501 1.738.372a.83.83 0 1 0 .83-.869.83.83 0 0 0-.744.468l-1.938-.41a.2.2 0 0 0-.153.028.2.2 0 0 0-.086.134l-.592 2.788c-1.24.038-2.358.41-3.17.992-.21-.2-.496-.324-.81-.324a1.163 1.163 0 0 0-.478 2.224q-.03.17-.029.353c0 1.795 2.091 3.256 4.669 3.256s4.668-1.451 4.668-3.256c0-.114-.01-.238-.029-.353.401-.181.688-.592.688-1.069 0-.65-.525-1.165-1.165-1.165"/></svg>
        </a>
      </nav>
    </div>
  </header>
  
          <section class="skill-page-header">
            <div class="skill-page-header-inner">
              <a href="/smart-home-iot/" class="back-link">‚Üê Back to Smart Home & IoT</a>
              <div class="skill-page-meta">
                <a href="/smart-home-iot/" class="skill-page-category">Smart Home & IoT</a>
                <span class="skill-page-author">by @leoyessi10-tech</span>
              </div>
              <h1 class="skill-page-title">context-engineering</h1>
              <p class="skill-page-desc">This skill should be used when the user asks</p>
              <div class="vote-widget skill-page-vote" data-category-id="smart-home-iot" data-tool-id="context-engineering">
                <button type="button" class="vote-btn" data-vote="1" aria-label="Upvote context-engineering">‚ñ≤</button>
                <span class="vote-count">New</span>
                <button type="button" class="vote-btn" data-vote="-1" aria-label="Downvote context-engineering">‚ñº</button>
              </div>
            </div>
          </section>
          <div class="skill-page-body">
            <article class="skill-page-content">
              <div class="skill-source-wrapper">
                <div class="skill-source-header">
                  <div class="skill-source-title">Source Code</div>
                  <button class="copy-btn" onclick="copySkillContent(this)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
                    Copy
                  </button>
                </div>
                <div class="markdown-content">
                  <h1>Context Compression Strategies</h1>
<p>When agent sessions generate millions of tokens of conversation history, compression becomes mandatory. The naive approach is aggressive compression to minimize tokens per request. The correct optimization target is tokens per task: total tokens consumed to complete a task, including re-fetching costs when compression loses critical information.</p>
<h2>When to Activate</h2>
<p>Activate this skill when:</p>
<ul>
<li>Agent sessions exceed context window limits</li>
<li>Codebases exceed context windows (5M+ token systems)</li>
<li>Designing conversation summarization strategies</li>
<li>Debugging cases where agents &quot;forget&quot; what files they modified</li>
<li>Building evaluation frameworks for compression quality</li>
</ul>
<h2>Core Concepts</h2>
<p>Context compression trades token savings against information loss. Three production-ready approaches exist:</p>
<ol>
<li><p><strong>Anchored Iterative Summarization</strong>: Maintain structured, persistent summaries with explicit sections for session intent, file modifications, decisions, and next steps. When compression triggers, summarize only the newly-truncated span and merge with the existing summary. Structure forces preservation by dedicating sections to specific information types.</p>
</li>
<li><p><strong>Opaque Compression</strong>: Produce compressed representations optimized for reconstruction fidelity. Achieves highest compression ratios (99%+) but sacrifices interpretability. Cannot verify what was preserved.</p>
</li>
<li><p><strong>Regenerative Full Summary</strong>: Generate detailed structured summaries on each compression. Produces readable output but may lose details across repeated compression cycles due to full regeneration rather than incremental merging.</p>
</li>
</ol>
<p>The critical insight: structure forces preservation. Dedicated sections act as checklists that the summarizer must populate, preventing silent information drift.</p>
<h2>Detailed Topics</h2>
<h3>Why Tokens-Per-Task Matters</h3>
<p>Traditional compression metrics target tokens-per-request. This is the wrong optimization. When compression loses critical details like file paths or error messages, the agent must re-fetch information, re-explore approaches, and waste tokens recovering context.</p>
<p>The right metric is tokens-per-task: total tokens consumed from task start to completion. A compression strategy saving 0.5% more tokens but causing 20% more re-fetching costs more overall.</p>
<h3>The Artifact Trail Problem</h3>
<p>Artifact trail integrity is the weakest dimension across all compression methods, scoring 2.2-2.5 out of 5.0 in evaluations. Even structured summarization with explicit file sections struggles to maintain complete file tracking across long sessions.</p>
<p>Coding agents need to know:</p>
<ul>
<li>Which files were created</li>
<li>Which files were modified and what changed</li>
<li>Which files were read but not changed</li>
<li>Function names, variable names, error messages</li>
</ul>
<p>This problem likely requires specialized handling beyond general summarization: a separate artifact index or explicit file-state tracking in agent scaffolding.</p>
<h3>Structured Summary Sections</h3>
<p>Effective structured summaries include explicit sections:</p>
<pre><code class="language-markdown">## Session Intent
[What the user is trying to accomplish]

## Files Modified
- auth.controller.ts: Fixed JWT token generation
- config/redis.ts: Updated connection pooling
- tests/auth.test.ts: Added mock setup for new config

## Decisions Made
- Using Redis connection pool instead of per-request connections
- Retry logic with exponential backoff for transient failures

## Current State
- 14 tests passing, 2 failing
- Remaining: mock setup for session service tests

## Next Steps
1. Fix remaining test failures
2. Run full test suite
3. Update documentation
</code></pre>
<p>This structure prevents silent loss of file paths or decisions because each section must be explicitly addressed.</p>
<h3>Compression Trigger Strategies</h3>
<p>When to trigger compression matters as much as how to compress:</p>
<table>
<thead>
<tr>
<th>Strategy</th>
<th>Trigger Point</th>
<th>Trade-off</th>
</tr>
</thead>
<tbody><tr>
<td>Fixed threshold</td>
<td>70-80% context utilization</td>
<td>Simple but may compress too early</td>
</tr>
<tr>
<td>Sliding window</td>
<td>Keep last N turns + summary</td>
<td>Predictable context size</td>
</tr>
<tr>
<td>Importance-based</td>
<td>Compress low-relevance sections first</td>
<td>Complex but preserves signal</td>
</tr>
<tr>
<td>Task-boundary</td>
<td>Compress at logical task completions</td>
<td>Clean summaries but unpredictable timing</td>
</tr>
</tbody></table>
<p>The sliding window approach with structured summaries provides the best balance of predictability and quality for most coding agent use cases.</p>
<h3>Probe-Based Evaluation</h3>
<p>Traditional metrics like ROUGE or embedding similarity fail to capture functional compression quality. A summary may score high on lexical overlap while missing the one file path the agent needs.</p>
<p>Probe-based evaluation directly measures functional quality by asking questions after compression:</p>
<table>
<thead>
<tr>
<th>Probe Type</th>
<th>What It Tests</th>
<th>Example Question</th>
</tr>
</thead>
<tbody><tr>
<td>Recall</td>
<td>Factual retention</td>
<td>&quot;What was the original error message?&quot;</td>
</tr>
<tr>
<td>Artifact</td>
<td>File tracking</td>
<td>&quot;Which files have we modified?&quot;</td>
</tr>
<tr>
<td>Continuation</td>
<td>Task planning</td>
<td>&quot;What should we do next?&quot;</td>
</tr>
<tr>
<td>Decision</td>
<td>Reasoning chain</td>
<td>&quot;What did we decide about the Redis issue?&quot;</td>
</tr>
</tbody></table>
<p>If compression preserved the right information, the agent answers correctly. If not, it guesses or hallucinates.</p>
<h3>Evaluation Dimensions</h3>
<p>Six dimensions capture compression quality for coding agents:</p>
<ol>
<li><strong>Accuracy</strong>: Are technical details correct? File paths, function names, error codes.</li>
<li><strong>Context Awareness</strong>: Does the response reflect current conversation state?</li>
<li><strong>Artifact Trail</strong>: Does the agent know which files were read or modified?</li>
<li><strong>Completeness</strong>: Does the response address all parts of the question?</li>
<li><strong>Continuity</strong>: Can work continue without re-fetching information?</li>
<li><strong>Instruction Following</strong>: Does the response respect stated constraints?</li>
</ol>
<p>Accuracy shows the largest variation between compression methods (0.6 point gap). Artifact trail is universally weak (2.2-2.5 range).</p>
<h2>Practical Guidance</h2>
<h3>Three-Phase Compression Workflow</h3>
<p>For large codebases or agent systems exceeding context windows, apply compression through three phases:</p>
<ol>
<li><p><strong>Research Phase</strong>: Produce a research document from architecture diagrams, documentation, and key interfaces. Compress exploration into a structured analysis of components and dependencies. Output: single research document.</p>
</li>
<li><p><strong>Planning Phase</strong>: Convert research into implementation specification with function signatures, type definitions, and data flow. A 5M token codebase compresses to approximately 2,000 words of specification.</p>
</li>
<li><p><strong>Implementation Phase</strong>: Execute against the specification. Context remains focused on the spec rather than raw codebase exploration.</p>
</li>
</ol>
<h3>Using Example Artifacts as Seeds</h3>
<p>When provided with a manual migration example or reference PR, use it as a template to understand the target pattern. The example reveals constraints that static analysis cannot surface: which invariants must hold, which services break on changes, and what a clean migration looks like.</p>
<p>This is particularly important when the agent cannot distinguish essential complexity (business requirements) from accidental complexity (legacy workarounds). The example artifact encodes that distinction.</p>
<h3>Implementing Anchored Iterative Summarization</h3>
<ol>
<li>Define explicit summary sections matching your agent&#39;s needs</li>
<li>On first compression trigger, summarize truncated history into sections</li>
<li>On subsequent compressions, summarize only new truncated content</li>
<li>Merge new summary into existing sections rather than regenerating</li>
<li>Track which information came from which compression cycle for debugging</li>
</ol>
<h3>When to Use Each Approach</h3>
<p><strong>Use anchored iterative summarization when:</strong></p>
<ul>
<li>Sessions are long-running (100+ messages)</li>
<li>File tracking matters (coding, debugging)</li>
<li>You need to verify what was preserved</li>
</ul>
<p><strong>Use opaque compression when:</strong></p>
<ul>
<li>Maximum token savings required</li>
<li>Sessions are relatively short</li>
<li>Re-fetching costs are low</li>
</ul>
<p><strong>Use regenerative summaries when:</strong></p>
<ul>
<li>Summary interpretability is critical</li>
<li>Sessions have clear phase boundaries</li>
<li>Full context review is acceptable on each compression</li>
</ul>
<h3>Compression Ratio Considerations</h3>
<table>
<thead>
<tr>
<th>Method</th>
<th>Compression Ratio</th>
<th>Quality Score</th>
<th>Trade-off</th>
</tr>
</thead>
<tbody><tr>
<td>Anchored Iterative</td>
<td>98.6%</td>
<td>3.70</td>
<td>Best quality, slightly less compression</td>
</tr>
<tr>
<td>Regenerative</td>
<td>98.7%</td>
<td>3.44</td>
<td>Good quality, moderate compression</td>
</tr>
<tr>
<td>Opaque</td>
<td>99.3%</td>
<td>3.35</td>
<td>Best compression, quality loss</td>
</tr>
</tbody></table>
<p>The 0.7% additional tokens retained by structured summarization buys 0.35 quality points. For any task where re-fetching costs matter, this trade-off favors structured approaches.</p>
<h2>Examples</h2>
<p><strong>Example 1: Debugging Session Compression</strong></p>
<p>Original context (89,000 tokens, 178 messages):</p>
<ul>
<li>401 error on /api/auth/login endpoint</li>
<li>Traced through auth controller, middleware, session store</li>
<li>Found stale Redis connection</li>
<li>Fixed connection pooling, added retry logic</li>
<li>14 tests passing, 2 failing</li>
</ul>
<p>Structured summary after compression:</p>
<pre><code class="language-markdown">## Session Intent
Debug 401 Unauthorized error on /api/auth/login despite valid credentials.

## Root Cause
Stale Redis connection in session store. JWT generated correctly but session could not be persisted.

## Files Modified
- auth.controller.ts: No changes (read only)
- middleware/cors.ts: No changes (examined)
- config/redis.ts: Fixed connection pooling configuration
- services/session.service.ts: Added retry logic for transient failures
- tests/auth.test.ts: Updated mock setup

## Test Status
14 passing, 2 failing (mock setup issues)

## Next Steps
1. Fix remaining test failures (mock session service)
2. Run full test suite
3. Deploy to staging
</code></pre>
<p><strong>Example 2: Probe Response Quality</strong></p>
<p>After compression, asking &quot;What was the original error?&quot;:</p>
<p>Good response (structured summarization):</p>
<blockquote>
<p>&quot;The original error was a 401 Unauthorized response from the /api/auth/login endpoint. Users received this error with valid credentials. Root cause was stale Redis connection in session store.&quot;</p>
</blockquote>
<p>Poor response (aggressive compression):</p>
<blockquote>
<p>&quot;We were debugging an authentication issue. The login was failing. We fixed some configuration problems.&quot;</p>
</blockquote>
<p>The structured response preserves endpoint, error code, and root cause. The aggressive response loses all technical detail.</p>
<h2>Guidelines</h2>
<ol>
<li>Optimize for tokens-per-task, not tokens-per-request</li>
<li>Use structured summaries with explicit sections for file tracking</li>
<li>Trigger compression at 70-80% context utilization</li>
<li>Implement incremental merging rather than full regeneration</li>
<li>Test compression quality with probe-based evaluation</li>
<li>Track artifact trail separately if file tracking is critical</li>
<li>Accept slightly lower compression ratios for better quality retention</li>
<li>Monitor re-fetching frequency as a compression quality signal</li>
</ol>
<h2>Integration</h2>
<p>This skill connects to several others in the collection:</p>
<ul>
<li>context-degradation - Compression is a mitigation strategy for degradation</li>
<li>context-optimization - Compression is one optimization technique among many</li>
<li>evaluation - Probe-based evaluation applies to compression testing</li>
<li>memory-systems - Compression relates to scratchpad and summary memory patterns</li>
</ul>
<h2>References</h2>
<p>Internal reference:</p>
<ul>
<li><a href="https://github.com/openclaw/skills/blob/main/skills/leoyessi10-tech/context-engineering/./references/evaluation-framework.md">Evaluation Framework Reference</a> - Detailed probe types and scoring rubrics</li>
</ul>
<p>Related skills in this collection:</p>
<ul>
<li>context-degradation - Understanding what compression prevents</li>
<li>context-optimization - Broader optimization strategies</li>
<li>evaluation - Building evaluation frameworks</li>
</ul>
<p>External resources:</p>
<ul>
<li>Factory Research: Evaluating Context Compression for AI Agents (December 2025)</li>
<li>Research on LLM-as-judge evaluation methodology (Zheng et al., 2023)</li>
<li>Netflix Engineering: &quot;The Infinite Software Crisis&quot; - Three-phase workflow and context compression at scale (AI Summit 2025)</li>
</ul>
<hr>
<h2>Skill Metadata</h2>
<p><strong>Created</strong>: 2025-12-22
<strong>Last Updated</strong>: 2025-12-26
<strong>Author</strong>: Agent Skills for Context Engineering Contributors
<strong>Version</strong>: 1.1.0</p>

                </div>
              </div>
            </article>
            <aside class="skill-page-sidebar">
              <div class="sidebar-card">
                <div class="sidebar-title">Actions</div>
                <a href="https://github.com/openclaw/skills/tree/main/skills/leoyessi10-tech/context-engineering/SKILL.md" target="_blank" rel="noopener" class="sidebar-btn sidebar-btn-primary">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/></svg>
                  View on GitHub
                </a>
                <a href="https://clawdhub.com/leoyessi10-tech/context-engineering" target="_blank" rel="noopener" class="sidebar-btn sidebar-btn-clawdhub">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/><line x1="2" y1="12" x2="22" y2="12"/></svg>
                  View on ClawdHub
                </a>
                <a href="https://raw.githubusercontent.com/openclaw/skills/main/skills/leoyessi10-tech/context-engineering/SKILL.md" download="SKILL.md" class="sidebar-btn sidebar-btn-secondary">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                  Download SKILL.md
                </a>
                <button onclick="sendToSecurityAuditor()" class="sidebar-btn sidebar-btn-security">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>
                  Security Check
                </button>
              </div>
              <div class="sidebar-card">
                <div class="sidebar-title">Details</div>
                <div class="sidebar-info">
                  <div class="sidebar-info-item">
                    <span class="sidebar-info-label">Author</span>
                    <span class="sidebar-info-value">@leoyessi10-tech</span>
                  </div>
                  <div class="sidebar-info-item">
                    <span class="sidebar-info-label">Category</span>
                    <span class="sidebar-info-value">Smart Home & IoT</span>
                  </div>
                </div>
              </div>
            </aside>
          </div>
        
  <footer class="footer">
    <div class="footer-inner">
      <p class="footer-text" style="margin-bottom: 8px;"><a href="https://github.com/neonone123/moltdirectory" target="_blank" rel="noopener" style="color: var(--accent); text-decoration: none;">View on GitHub</a></p>
      <p class="footer-text" style="opacity: 0.6; font-size: 13px;">OpenClawDirectory.com is a community-run project and is not affiliated with the official OpenClaw team or Peter Steinberger. We are just fans of the lobster.</p>
    </div>
  </footer>
  <script>
    function toggleTheme() {
      const html = document.documentElement;
      const currentTheme = html.getAttribute('data-theme');
      const newTheme = currentTheme === 'light' ? 'dark' : 'light';
      if (newTheme === 'light') {
        html.setAttribute('data-theme', 'light');
      } else {
        html.removeAttribute('data-theme');
      }
      localStorage.setItem('theme', newTheme);
    }
    
    function copySkillContent(btn) {
      const wrapper = btn.closest('.skill-source-wrapper');
      const content = wrapper.querySelector('.markdown-content');
      if (content) {
        const text = content.innerText || content.textContent;
        navigator.clipboard.writeText(text).then(() => {
          btn.classList.add('copied');
          btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg> Copied!';
          setTimeout(() => {
            btn.classList.remove('copied');
            btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg> Copy';
          }, 2000);
        });
      }
    }

    async function sendToSecurityAuditor() {
      try {
        const contentElement = document.querySelector('.markdown-content');
        if (!contentElement) throw new Error('Could not find markdown content');
        const skillContent = contentElement.innerText || contentElement.textContent;
        localStorage.setItem('skillAuditContent', skillContent);
        window.open('/security-auditor', '_blank'); 
      } catch (error) {
        alert('Error: ' + error.message);
      }
    }

    function updateVoteWidget(widget, toolData) {
      if (!widget || !toolData) return;
      const upBtn = widget.querySelector('[data-vote="1"]');
      const downBtn = widget.querySelector('[data-vote="-1"]');
      const countNode = widget.querySelector('.vote-count');
      widget.dataset.rankScore = String(toolData.rankScore ?? 0);
      widget.dataset.viewerVote = String(toolData.viewerVote ?? 0);

      if (countNode) {
        countNode.textContent = toolData.displayCount || 'New';
      }
      if (upBtn) {
        upBtn.classList.toggle('is-active', Number(toolData.viewerVote) === 1);
      }
      if (downBtn) {
        downBtn.classList.toggle('is-active', Number(toolData.viewerVote) === -1);
      }
    }

    function setWidgetBusy(widget, busy) {
      widget.dataset.busy = busy ? '1' : '0';
      widget.querySelectorAll('.vote-btn').forEach((btn) => {
        btn.disabled = busy;
      });
    }

    function applySortMode(grid, mode) {
      const cards = [...grid.querySelectorAll('.skill-card[data-tool-id]')];
      cards.sort((a, b) => {
        if (mode === 'community') {
          const scoreDiff = Number(b.dataset.rankScore || 0) - Number(a.dataset.rankScore || 0);
          if (scoreDiff !== 0) return scoreDiff;
        }
        return Number(a.dataset.originalIndex || 0) - Number(b.dataset.originalIndex || 0);
      });
      cards.forEach((card) => grid.appendChild(card));
    }

    function bindSortToggle(toolbar, grid) {
      const buttons = toolbar.querySelectorAll('.sort-toggle-btn');
      const status = toolbar.querySelector('.sort-status');
      buttons.forEach((btn) => {
        btn.addEventListener('click', () => {
          const mode = btn.dataset.sortMode;
          buttons.forEach((b) => b.classList.toggle('is-active', b === btn));
          applySortMode(grid, mode);
          status.textContent = mode === 'community' ? 'Community ranking active' : 'Original order active';
        });
      });
    }

    async function fetchScores(categoryId, toolIds) {
      const params = new URLSearchParams({
        categoryId,
        toolIds: toolIds.join(',')
      });
      const response = await fetch('/api/v1/scores?' + params.toString(), {
        method: 'GET',
        credentials: 'same-origin'
      });
      if (!response.ok) {
        throw new Error('Unable to fetch vote scores');
      }
      return response.json();
    }

    async function submitVote(widget, voteValue) {
      const categoryId = widget.dataset.categoryId;
      const toolId = widget.dataset.toolId;
      setWidgetBusy(widget, true);
      try {
        const response = await fetch('/api/v1/vote', {
          method: 'POST',
          credentials: 'same-origin',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            categoryId,
            toolId,
            vote: voteValue
          })
        });
        const payload = await response.json().catch(() => ({}));
        if (!response.ok) {
          throw new Error(payload.error || 'Vote request failed');
        }
        if (payload.tool) {
          updateVoteWidget(widget, payload.tool);
          const card = widget.closest('.skill-card[data-tool-id]');
          if (card) {
            card.dataset.rankScore = String(payload.tool.rankScore ?? 0);
          }
        }
      } catch (error) {
        console.error(error);
      } finally {
        setWidgetBusy(widget, false);
      }
    }

    document.addEventListener('DOMContentLoaded', async () => {
      const widgets = [...document.querySelectorAll('.vote-widget[data-category-id][data-tool-id]')];
      if (widgets.length === 0) return;

      const grouped = new Map();
      widgets.forEach((widget) => {
        const key = widget.dataset.categoryId;
        if (!grouped.has(key)) grouped.set(key, new Map());
        grouped.get(key).set(widget.dataset.toolId, widget);
      });

      for (const [categoryId, widgetMap] of grouped.entries()) {
        const toolIds = [...widgetMap.keys()];
        try {
          const data = await fetchScores(categoryId, toolIds);
          const byTool = new Map((data.tools || []).map((tool) => [tool.toolId, tool]));
          for (const [toolId, widget] of widgetMap.entries()) {
            const toolData = byTool.get(toolId);
            if (toolData) {
              updateVoteWidget(widget, toolData);
              const card = widget.closest('.skill-card[data-tool-id]');
              if (card) {
                card.dataset.rankScore = String(toolData.rankScore ?? 0);
              }
            }
          }
        } catch (error) {
          console.error(error);
        }
      }

      widgets.forEach((widget) => {
        widget.querySelectorAll('.vote-btn').forEach((btn) => {
          btn.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            if (widget.dataset.busy === '1') return;
            const voteValue = Number(btn.dataset.vote);
            submitVote(widget, voteValue).then(() => {
              const grid = widget.closest('.skills-grid[data-category-id]');
              const toolbar = document.querySelector('.sort-toolbar[data-category-id="' + widget.dataset.categoryId + '"]');
              const communityBtn = toolbar ? toolbar.querySelector('.sort-toggle-btn[data-sort-mode="community"]') : null;
              if (grid && communityBtn && communityBtn.classList.contains('is-active')) {
                applySortMode(grid, 'community');
              }
            });
          });
        });
      });

      document.querySelectorAll('.skills-grid[data-category-id]').forEach((grid) => {
        const categoryId = grid.dataset.categoryId;
        const toolbar = document.querySelector('.sort-toolbar[data-category-id="' + categoryId + '"]');
        if (!toolbar) return;
        bindSortToggle(toolbar, grid);
        applySortMode(grid, 'community');
      });
    });
  </script>
</body>
</html>