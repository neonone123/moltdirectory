<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Ultimate AI agent memory system">
  <title>elite-longterm-memory - OpenClaw Directory</title>
  <link rel="canonical" href="https://moltdirectory.com/notes-pkm/elite-longterm-memory/">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ¦</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/style.css">
  <script>
    // Apply saved theme before page renders to prevent flash
    (function() {
      const savedTheme = localStorage.getItem('theme') || 'dark';
      if (savedTheme === 'light') {
        document.documentElement.setAttribute('data-theme', 'light');
      }
    })();
  </script>
</head>
<body>
  <header class="header">
    <div class="header-inner">
      <a href="/" class="logo">

        <span class="logo-text">OpenClaw Directory</span>
      </a>
      <nav class="header-links">
        <a href="/start-here/" class="header-link">Start Here</a>
        <a href="/security-auditor" class="header-link">Security Auditor</a>
        <a href="https://github.com/neonone123/moltdirectory/issues/new?template=add-skill.yml" class="header-link" target="_blank" rel="noopener">Add Skill</a>
        <button class="theme-toggle" aria-label="Toggle theme" onclick="toggleTheme()">
          <svg class="icon-moon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
          <svg class="icon-sun" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
        </button>
        <a href="https://www.reddit.com/r/OpenClawDirectory/" class="header-link" target="_blank" rel="noopener" aria-label="Community">
          <svg viewBox="0 0 16 16" fill="currentColor" width="28" height="28"><path d="M6.167 8a.83.83 0 0 0-.83.83c0 .459.372.84.83.831a.831.831 0 0 0 0-1.661m1.843 3.647c.315 0 1.403-.038 1.976-.611a.23.23 0 0 0 0-.306.213.213 0 0 0-.306 0c-.353.363-1.126.487-1.67.487-.545 0-1.308-.124-1.671-.487a.213.213 0 0 0-.306 0 .213.213 0 0 0 0 .306c.564.563 1.652.61 1.977.61zm.992-2.807c0 .458.373.83.831.83s.83-.381.83-.83a.831.831 0 0 0-1.66 0z"/><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0m-3.828-1.165c-.315 0-.602.124-.812.325-.801-.573-1.9-.945-3.121-.993l.534-2.501 1.738.372a.83.83 0 1 0 .83-.869.83.83 0 0 0-.744.468l-1.938-.41a.2.2 0 0 0-.153.028.2.2 0 0 0-.086.134l-.592 2.788c-1.24.038-2.358.41-3.17.992-.21-.2-.496-.324-.81-.324a1.163 1.163 0 0 0-.478 2.224q-.03.17-.029.353c0 1.795 2.091 3.256 4.669 3.256s4.668-1.451 4.668-3.256c0-.114-.01-.238-.029-.353.401-.181.688-.592.688-1.069 0-.65-.525-1.165-1.165-1.165"/></svg>
        </a>
      </nav>
    </div>
  </header>
  
          <section class="skill-page-header">
            <div class="skill-page-header-inner">
              <a href="/notes-pkm/" class="back-link">â† Back to Notes & PKM</a>
              <div class="skill-page-meta">
                <a href="/notes-pkm/" class="skill-page-category">Notes & PKM</a>
                <span class="skill-page-author">by @nextfrontierbuilds</span>
              </div>
              <h1 class="skill-page-title">elite-longterm-memory</h1>
              <p class="skill-page-desc">Ultimate AI agent memory system</p>
              <div class="vote-widget skill-page-vote" data-category-id="notes-pkm" data-tool-id="elite-longterm-memory">
                <button type="button" class="vote-btn" data-vote="1" aria-label="Upvote elite-longterm-memory">â–²</button>
                <span class="vote-count">New</span>
                <button type="button" class="vote-btn" data-vote="-1" aria-label="Downvote elite-longterm-memory">â–¼</button>
              </div>
            </div>
          </section>
          <div class="skill-page-body">
            <article class="skill-page-content">
              <div class="skill-source-wrapper">
                <div class="skill-source-header">
                  <div class="skill-source-title">Source Code</div>
                  <button class="copy-btn" onclick="copySkillContent(this)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
                    Copy
                  </button>
                </div>
                <div class="markdown-content">
                  <h1>Elite Longterm Memory ğŸ§ </h1>
<p><strong>The ultimate memory system for AI agents.</strong> Combines 6 proven approaches into one bulletproof architecture.</p>
<p>Never lose context. Never forget decisions. Never repeat mistakes.</p>
<h2>Architecture Overview</h2>
<pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    ELITE LONGTERM MEMORY                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”             â”‚
â”‚  â”‚   HOT RAM   â”‚  â”‚  WARM STORE â”‚  â”‚  COLD STORE â”‚             â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚             â”‚             â”‚
â”‚  â”‚ SESSION-    â”‚  â”‚  LanceDB    â”‚  â”‚  Git-Notes  â”‚             â”‚
â”‚  â”‚ STATE.md    â”‚  â”‚  Vectors    â”‚  â”‚  Knowledge  â”‚             â”‚
â”‚  â”‚             â”‚  â”‚             â”‚  â”‚  Graph      â”‚             â”‚
â”‚  â”‚ (survives   â”‚  â”‚ (semantic   â”‚  â”‚ (permanent  â”‚             â”‚
â”‚  â”‚  compaction)â”‚  â”‚  search)    â”‚  â”‚  decisions) â”‚             â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜             â”‚
â”‚         â”‚                â”‚                â”‚                     â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â”‚                          â–¼                                      â”‚
â”‚                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚                  â”‚  MEMORY.md  â”‚  â† Curated long-term           â”‚
â”‚                  â”‚  + daily/   â”‚    (human-readable)            â”‚
â”‚                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â”‚                          â”‚                                      â”‚
â”‚                          â–¼                                      â”‚
â”‚                  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                                â”‚
â”‚                  â”‚ SuperMemory â”‚  â† Cloud backup (optional)     â”‚
â”‚                  â”‚    API      â”‚                                â”‚
â”‚                  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                â”‚
â”‚                                                                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
</code></pre>
<h2>The 5 Memory Layers</h2>
<h3>Layer 1: HOT RAM (SESSION-STATE.md)</h3>
<p><strong>From: bulletproof-memory</strong></p>
<p>Active working memory that survives compaction. Write-Ahead Log protocol.</p>
<pre><code class="language-markdown"># SESSION-STATE.md â€” Active Working Memory

## Current Task
[What we&#39;re working on RIGHT NOW]

## Key Context
- User preference: ...
- Decision made: ...
- Blocker: ...

## Pending Actions
- [ ] ...
</code></pre>
<p><strong>Rule:</strong> Write BEFORE responding. Triggered by user input, not agent memory.</p>
<h3>Layer 2: WARM STORE (LanceDB Vectors)</h3>
<p><strong>From: lancedb-memory</strong></p>
<p>Semantic search across all memories. Auto-recall injects relevant context.</p>
<pre><code class="language-bash"># Auto-recall (happens automatically)
memory_recall query=&quot;project status&quot; limit=5

# Manual store
memory_store text=&quot;User prefers dark mode&quot; category=&quot;preference&quot; importance=0.9
</code></pre>
<h3>Layer 3: COLD STORE (Git-Notes Knowledge Graph)</h3>
<p><strong>From: git-notes-memory</strong></p>
<p>Structured decisions, learnings, and context. Branch-aware.</p>
<pre><code class="language-bash"># Store a decision (SILENT - never announce)
python3 memory.py -p $DIR remember &#39;{&quot;type&quot;:&quot;decision&quot;,&quot;content&quot;:&quot;Use React for frontend&quot;}&#39; -t tech -i h

# Retrieve context
python3 memory.py -p $DIR get &quot;frontend&quot;
</code></pre>
<h3>Layer 4: CURATED ARCHIVE (MEMORY.md + daily/)</h3>
<p><strong>From: OpenClaw native</strong></p>
<p>Human-readable long-term memory. Daily logs + distilled wisdom.</p>
<pre><code>workspace/
â”œâ”€â”€ MEMORY.md              # Curated long-term (the good stuff)
â””â”€â”€ memory/
    â”œâ”€â”€ 2026-01-30.md      # Daily log
    â”œâ”€â”€ 2026-01-29.md
    â””â”€â”€ topics/            # Topic-specific files
</code></pre>
<h3>Layer 5: CLOUD BACKUP (SuperMemory) â€” Optional</h3>
<p><strong>From: supermemory</strong></p>
<p>Cross-device sync. Chat with your knowledge base.</p>
<pre><code class="language-bash">export SUPERMEMORY_API_KEY=&quot;your-key&quot;
supermemory add &quot;Important context&quot;
supermemory search &quot;what did we decide about...&quot;
</code></pre>
<h3>Layer 6: AUTO-EXTRACTION (Mem0) â€” Recommended</h3>
<p><strong>NEW: Automatic fact extraction</strong></p>
<p>Mem0 automatically extracts facts from conversations. 80% token reduction.</p>
<pre><code class="language-bash">npm install mem0ai
export MEM0_API_KEY=&quot;your-key&quot;
</code></pre>
<pre><code class="language-javascript">const { MemoryClient } = require(&#39;mem0ai&#39;);
const client = new MemoryClient({ apiKey: process.env.MEM0_API_KEY });

// Conversations auto-extract facts
await client.add(messages, { user_id: &quot;user123&quot; });

// Retrieve relevant memories
const memories = await client.search(query, { user_id: &quot;user123&quot; });
</code></pre>
<p>Benefits:</p>
<ul>
<li>Auto-extracts preferences, decisions, facts</li>
<li>Deduplicates and updates existing memories</li>
<li>80% reduction in tokens vs raw history</li>
<li>Works across sessions automatically</li>
</ul>
<h2>Quick Setup</h2>
<h3>1. Create SESSION-STATE.md (Hot RAM)</h3>
<pre><code class="language-bash">cat &gt; SESSION-STATE.md &lt;&lt; &#39;EOF&#39;
# SESSION-STATE.md â€” Active Working Memory

This file is the agent&#39;s &quot;RAM&quot; â€” survives compaction, restarts, distractions.

## Current Task
[None]

## Key Context
[None yet]

## Pending Actions
- [ ] None

## Recent Decisions
[None yet]

---
*Last updated: [timestamp]*
EOF
</code></pre>
<h3>2. Enable LanceDB (Warm Store)</h3>
<p>In <code>~/.openclaw/openclaw.json</code>:</p>
<pre><code class="language-json">{
  &quot;memorySearch&quot;: {
    &quot;enabled&quot;: true,
    &quot;provider&quot;: &quot;openai&quot;,
    &quot;sources&quot;: [&quot;memory&quot;],
    &quot;minScore&quot;: 0.3,
    &quot;maxResults&quot;: 10
  },
  &quot;plugins&quot;: {
    &quot;entries&quot;: {
      &quot;memory-lancedb&quot;: {
        &quot;enabled&quot;: true,
        &quot;config&quot;: {
          &quot;autoCapture&quot;: false,
          &quot;autoRecall&quot;: true,
          &quot;captureCategories&quot;: [&quot;preference&quot;, &quot;decision&quot;, &quot;fact&quot;],
          &quot;minImportance&quot;: 0.7
        }
      }
    }
  }
}
</code></pre>
<h3>3. Initialize Git-Notes (Cold Store)</h3>
<pre><code class="language-bash">cd ~/clawd
git init  # if not already
python3 skills/git-notes-memory/memory.py -p . sync --start
</code></pre>
<h3>4. Verify MEMORY.md Structure</h3>
<pre><code class="language-bash"># Ensure you have:
# - MEMORY.md in workspace root
# - memory/ folder for daily logs
mkdir -p memory
</code></pre>
<h3>5. (Optional) Setup SuperMemory</h3>
<pre><code class="language-bash">export SUPERMEMORY_API_KEY=&quot;your-key&quot;
# Add to ~/.zshrc for persistence
</code></pre>
<h2>Agent Instructions</h2>
<h3>On Session Start</h3>
<ol>
<li>Read SESSION-STATE.md â€” this is your hot context</li>
<li>Run <code>memory_search</code> for relevant prior context</li>
<li>Check memory/YYYY-MM-DD.md for recent activity</li>
</ol>
<h3>During Conversation</h3>
<ol>
<li><strong>User gives concrete detail?</strong> â†’ Write to SESSION-STATE.md BEFORE responding</li>
<li><strong>Important decision made?</strong> â†’ Store in Git-Notes (SILENTLY)</li>
<li><strong>Preference expressed?</strong> â†’ <code>memory_store</code> with importance=0.9</li>
</ol>
<h3>On Session End</h3>
<ol>
<li>Update SESSION-STATE.md with final state</li>
<li>Move significant items to MEMORY.md if worth keeping long-term</li>
<li>Create/update daily log in memory/YYYY-MM-DD.md</li>
</ol>
<h3>Memory Hygiene (Weekly)</h3>
<ol>
<li>Review SESSION-STATE.md â€” archive completed tasks</li>
<li>Check LanceDB for junk: <code>memory_recall query=&quot;*&quot; limit=50</code></li>
<li>Clear irrelevant vectors: <code>memory_forget id=&lt;id&gt;</code></li>
<li>Consolidate daily logs into MEMORY.md</li>
</ol>
<h2>The WAL Protocol (Critical)</h2>
<p><strong>Write-Ahead Log:</strong> Write state BEFORE responding, not after.</p>
<table>
<thead>
<tr>
<th>Trigger</th>
<th>Action</th>
</tr>
</thead>
<tbody><tr>
<td>User states preference</td>
<td>Write to SESSION-STATE.md â†’ then respond</td>
</tr>
<tr>
<td>User makes decision</td>
<td>Write to SESSION-STATE.md â†’ then respond</td>
</tr>
<tr>
<td>User gives deadline</td>
<td>Write to SESSION-STATE.md â†’ then respond</td>
</tr>
<tr>
<td>User corrects you</td>
<td>Write to SESSION-STATE.md â†’ then respond</td>
</tr>
</tbody></table>
<p><strong>Why?</strong> If you respond first and crash/compact before saving, context is lost. WAL ensures durability.</p>
<h2>Example Workflow</h2>
<pre><code>User: &quot;Let&#39;s use Tailwind for this project, not vanilla CSS&quot;

Agent (internal):
1. Write to SESSION-STATE.md: &quot;Decision: Use Tailwind, not vanilla CSS&quot;
2. Store in Git-Notes: decision about CSS framework
3. memory_store: &quot;User prefers Tailwind over vanilla CSS&quot; importance=0.9
4. THEN respond: &quot;Got it â€” Tailwind it is...&quot;
</code></pre>
<h2>Maintenance Commands</h2>
<pre><code class="language-bash"># Audit vector memory
memory_recall query=&quot;*&quot; limit=50

# Clear all vectors (nuclear option)
rm -rf ~/.openclaw/memory/lancedb/
openclaw gateway restart

# Export Git-Notes
python3 memory.py -p . export --format json &gt; memories.json

# Check memory health
du -sh ~/.openclaw/memory/
wc -l MEMORY.md
ls -la memory/
</code></pre>
<h2>Why Memory Fails</h2>
<p>Understanding the root causes helps you fix them:</p>
<table>
<thead>
<tr>
<th>Failure Mode</th>
<th>Cause</th>
<th>Fix</th>
</tr>
</thead>
<tbody><tr>
<td>Forgets everything</td>
<td><code>memory_search</code> disabled</td>
<td>Enable + add OpenAI key</td>
</tr>
<tr>
<td>Files not loaded</td>
<td>Agent skips reading memory</td>
<td>Add to AGENTS.md rules</td>
</tr>
<tr>
<td>Facts not captured</td>
<td>No auto-extraction</td>
<td>Use Mem0 or manual logging</td>
</tr>
<tr>
<td>Sub-agents isolated</td>
<td>Don&#39;t inherit context</td>
<td>Pass context in task prompt</td>
</tr>
<tr>
<td>Repeats mistakes</td>
<td>Lessons not logged</td>
<td>Write to memory/lessons.md</td>
</tr>
</tbody></table>
<h2>Solutions (Ranked by Effort)</h2>
<h3>1. Quick Win: Enable memory_search</h3>
<p>If you have an OpenAI key, enable semantic search:</p>
<pre><code class="language-bash">openclaw configure --section web
</code></pre>
<p>This enables vector search over MEMORY.md + memory/*.md files.</p>
<h3>2. Recommended: Mem0 Integration</h3>
<p>Auto-extract facts from conversations. 80% token reduction.</p>
<pre><code class="language-bash">npm install mem0ai
</code></pre>
<pre><code class="language-javascript">const { MemoryClient } = require(&#39;mem0ai&#39;);

const client = new MemoryClient({ apiKey: process.env.MEM0_API_KEY });

// Auto-extract and store
await client.add([
  { role: &quot;user&quot;, content: &quot;I prefer Tailwind over vanilla CSS&quot; }
], { user_id: &quot;ty&quot; });

// Retrieve relevant memories
const memories = await client.search(&quot;CSS preferences&quot;, { user_id: &quot;ty&quot; });
</code></pre>
<h3>3. Better File Structure (No Dependencies)</h3>
<pre><code>memory/
â”œâ”€â”€ projects/
â”‚   â”œâ”€â”€ strykr.md
â”‚   â””â”€â”€ taska.md
â”œâ”€â”€ people/
â”‚   â””â”€â”€ contacts.md
â”œâ”€â”€ decisions/
â”‚   â””â”€â”€ 2026-01.md
â”œâ”€â”€ lessons/
â”‚   â””â”€â”€ mistakes.md
â””â”€â”€ preferences.md
</code></pre>
<p>Keep MEMORY.md as a summary (&lt;5KB), link to detailed files.</p>
<h2>Immediate Fixes Checklist</h2>
<table>
<thead>
<tr>
<th>Problem</th>
<th>Fix</th>
</tr>
</thead>
<tbody><tr>
<td>Forgets preferences</td>
<td>Add <code>## Preferences</code> section to MEMORY.md</td>
</tr>
<tr>
<td>Repeats mistakes</td>
<td>Log every mistake to <code>memory/lessons.md</code></td>
</tr>
<tr>
<td>Sub-agents lack context</td>
<td>Include key context in spawn task prompt</td>
</tr>
<tr>
<td>Forgets recent work</td>
<td>Strict daily file discipline</td>
</tr>
<tr>
<td>Memory search not working</td>
<td>Check <code>OPENAI_API_KEY</code> is set</td>
</tr>
</tbody></table>
<h2>Troubleshooting</h2>
<p><strong>Agent keeps forgetting mid-conversation:</strong>
â†’ SESSION-STATE.md not being updated. Check WAL protocol.</p>
<p><strong>Irrelevant memories injected:</strong>
â†’ Disable autoCapture, increase minImportance threshold.</p>
<p><strong>Memory too large, slow recall:</strong>
â†’ Run hygiene: clear old vectors, archive daily logs.</p>
<p><strong>Git-Notes not persisting:</strong>
â†’ Run <code>git notes push</code> to sync with remote.</p>
<p><strong>memory_search returns nothing:</strong>
â†’ Check OpenAI API key: <code>echo $OPENAI_API_KEY</code>
â†’ Verify memorySearch enabled in openclaw.json</p>
<hr>
<h2>Links</h2>
<ul>
<li>bulletproof-memory: <a href="https://clawdhub.com/skills/bulletproof-memory">https://clawdhub.com/skills/bulletproof-memory</a></li>
<li>lancedb-memory: <a href="https://clawdhub.com/skills/lancedb-memory">https://clawdhub.com/skills/lancedb-memory</a></li>
<li>git-notes-memory: <a href="https://clawdhub.com/skills/git-notes-memory">https://clawdhub.com/skills/git-notes-memory</a></li>
<li>memory-hygiene: <a href="https://clawdhub.com/skills/memory-hygiene">https://clawdhub.com/skills/memory-hygiene</a></li>
<li>supermemory: <a href="https://clawdhub.com/skills/supermemory">https://clawdhub.com/skills/supermemory</a></li>
</ul>
<hr>
<p><em>Built by <a href="https://x.com/NextXFrontier">@NextXFrontier</a> â€” Part of the Next Frontier AI toolkit</em></p>

                </div>
              </div>
            </article>
            <aside class="skill-page-sidebar">
              <div class="sidebar-card">
                <div class="sidebar-title">Actions</div>
                <a href="https://github.com/openclaw/skills/tree/main/skills/nextfrontierbuilds/elite-longterm-memory/SKILL.md" target="_blank" rel="noopener" class="sidebar-btn sidebar-btn-primary">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/></svg>
                  View on GitHub
                </a>
                <a href="https://clawdhub.com/nextfrontierbuilds/elite-longterm-memory" target="_blank" rel="noopener" class="sidebar-btn sidebar-btn-clawdhub">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/><line x1="2" y1="12" x2="22" y2="12"/></svg>
                  View on ClawdHub
                </a>
                <a href="https://raw.githubusercontent.com/openclaw/skills/main/skills/nextfrontierbuilds/elite-longterm-memory/SKILL.md" download="SKILL.md" class="sidebar-btn sidebar-btn-secondary">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                  Download SKILL.md
                </a>
                <button onclick="sendToSecurityAuditor()" class="sidebar-btn sidebar-btn-security">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>
                  Security Check
                </button>
              </div>
              <div class="sidebar-card">
                <div class="sidebar-title">Details</div>
                <div class="sidebar-info">
                  <div class="sidebar-info-item">
                    <span class="sidebar-info-label">Author</span>
                    <span class="sidebar-info-value">@nextfrontierbuilds</span>
                  </div>
                  <div class="sidebar-info-item">
                    <span class="sidebar-info-label">Category</span>
                    <span class="sidebar-info-value">Notes & PKM</span>
                  </div>
                </div>
              </div>
            </aside>
          </div>
        
  <footer class="footer">
    <div class="footer-inner">
      <p class="footer-text" style="margin-bottom: 8px;"><a href="https://github.com/neonone123/moltdirectory" target="_blank" rel="noopener" style="color: var(--accent); text-decoration: none;">View on GitHub</a></p>
      <p class="footer-text" style="opacity: 0.6; font-size: 13px;">OpenClawDirectory.com is a community-run project and is not affiliated with the official OpenClaw team or Peter Steinberger. We are just fans of the lobster.</p>
    </div>
  </footer>
  <script>
    function toggleTheme() {
      const html = document.documentElement;
      const currentTheme = html.getAttribute('data-theme');
      const newTheme = currentTheme === 'light' ? 'dark' : 'light';
      if (newTheme === 'light') {
        html.setAttribute('data-theme', 'light');
      } else {
        html.removeAttribute('data-theme');
      }
      localStorage.setItem('theme', newTheme);
    }
    
    function copySkillContent(btn) {
      const wrapper = btn.closest('.skill-source-wrapper');
      const content = wrapper.querySelector('.markdown-content');
      if (content) {
        const text = content.innerText || content.textContent;
        navigator.clipboard.writeText(text).then(() => {
          btn.classList.add('copied');
          btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg> Copied!';
          setTimeout(() => {
            btn.classList.remove('copied');
            btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg> Copy';
          }, 2000);
        });
      }
    }

    async function sendToSecurityAuditor() {
      try {
        const contentElement = document.querySelector('.markdown-content');
        if (!contentElement) throw new Error('Could not find markdown content');
        const skillContent = contentElement.innerText || contentElement.textContent;
        localStorage.setItem('skillAuditContent', skillContent);
        window.open('/security-auditor', '_blank'); 
      } catch (error) {
        alert('Error: ' + error.message);
      }
    }

    function updateVoteWidget(widget, toolData) {
      if (!widget || !toolData) return;
      const upBtn = widget.querySelector('[data-vote="1"]');
      const downBtn = widget.querySelector('[data-vote="-1"]');
      const countNode = widget.querySelector('.vote-count');
      widget.dataset.rankScore = String(toolData.rankScore ?? 0);
      widget.dataset.viewerVote = String(toolData.viewerVote ?? 0);

      if (countNode) {
        countNode.textContent = toolData.displayCount || 'New';
      }
      if (upBtn) {
        upBtn.classList.toggle('is-active', Number(toolData.viewerVote) === 1);
      }
      if (downBtn) {
        downBtn.classList.toggle('is-active', Number(toolData.viewerVote) === -1);
      }
    }

    function setWidgetBusy(widget, busy) {
      widget.dataset.busy = busy ? '1' : '0';
      widget.querySelectorAll('.vote-btn').forEach((btn) => {
        btn.disabled = busy;
      });
    }

    function applySortMode(grid, mode) {
      const cards = [...grid.querySelectorAll('.skill-card[data-tool-id]')];
      cards.sort((a, b) => {
        if (mode === 'community') {
          const scoreDiff = Number(b.dataset.rankScore || 0) - Number(a.dataset.rankScore || 0);
          if (scoreDiff !== 0) return scoreDiff;
        }
        return Number(a.dataset.originalIndex || 0) - Number(b.dataset.originalIndex || 0);
      });
      cards.forEach((card) => grid.appendChild(card));
    }

    function bindSortToggle(toolbar, grid) {
      const buttons = toolbar.querySelectorAll('.sort-toggle-btn');
      const status = toolbar.querySelector('.sort-status');
      buttons.forEach((btn) => {
        btn.addEventListener('click', () => {
          const mode = btn.dataset.sortMode;
          buttons.forEach((b) => b.classList.toggle('is-active', b === btn));
          applySortMode(grid, mode);
          status.textContent = mode === 'community' ? 'Community ranking active' : 'Original order active';
        });
      });
    }

    async function fetchScores(categoryId, toolIds) {
      const params = new URLSearchParams({
        categoryId,
        toolIds: toolIds.join(',')
      });
      const response = await fetch('/api/v1/scores?' + params.toString(), {
        method: 'GET',
        credentials: 'same-origin'
      });
      if (!response.ok) {
        throw new Error('Unable to fetch vote scores');
      }
      return response.json();
    }

    async function submitVote(widget, voteValue) {
      const categoryId = widget.dataset.categoryId;
      const toolId = widget.dataset.toolId;
      setWidgetBusy(widget, true);
      try {
        const response = await fetch('/api/v1/vote', {
          method: 'POST',
          credentials: 'same-origin',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            categoryId,
            toolId,
            vote: voteValue
          })
        });
        const payload = await response.json().catch(() => ({}));
        if (!response.ok) {
          throw new Error(payload.error || 'Vote request failed');
        }
        if (payload.tool) {
          updateVoteWidget(widget, payload.tool);
          const card = widget.closest('.skill-card[data-tool-id]');
          if (card) {
            card.dataset.rankScore = String(payload.tool.rankScore ?? 0);
          }
        }
      } catch (error) {
        console.error(error);
      } finally {
        setWidgetBusy(widget, false);
      }
    }

    document.addEventListener('DOMContentLoaded', async () => {
      const widgets = [...document.querySelectorAll('.vote-widget[data-category-id][data-tool-id]')];
      if (widgets.length === 0) return;

      const grouped = new Map();
      widgets.forEach((widget) => {
        const key = widget.dataset.categoryId;
        if (!grouped.has(key)) grouped.set(key, new Map());
        grouped.get(key).set(widget.dataset.toolId, widget);
      });

      for (const [categoryId, widgetMap] of grouped.entries()) {
        const toolIds = [...widgetMap.keys()];
        try {
          const data = await fetchScores(categoryId, toolIds);
          const byTool = new Map((data.tools || []).map((tool) => [tool.toolId, tool]));
          for (const [toolId, widget] of widgetMap.entries()) {
            const toolData = byTool.get(toolId);
            if (toolData) {
              updateVoteWidget(widget, toolData);
              const card = widget.closest('.skill-card[data-tool-id]');
              if (card) {
                card.dataset.rankScore = String(toolData.rankScore ?? 0);
              }
            }
          }
        } catch (error) {
          console.error(error);
        }
      }

      widgets.forEach((widget) => {
        widget.querySelectorAll('.vote-btn').forEach((btn) => {
          btn.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            if (widget.dataset.busy === '1') return;
            const voteValue = Number(btn.dataset.vote);
            submitVote(widget, voteValue).then(() => {
              const grid = widget.closest('.skills-grid[data-category-id]');
              const toolbar = document.querySelector('.sort-toolbar[data-category-id="' + widget.dataset.categoryId + '"]');
              const communityBtn = toolbar ? toolbar.querySelector('.sort-toggle-btn[data-sort-mode="community"]') : null;
              if (grid && communityBtn && communityBtn.classList.contains('is-active')) {
                applySortMode(grid, 'community');
              }
            });
          });
        });
      });

      document.querySelectorAll('.skills-grid[data-category-id]').forEach((grid) => {
        const categoryId = grid.dataset.categoryId;
        const toolbar = document.querySelector('.sort-toolbar[data-category-id="' + categoryId + '"]');
        if (!toolbar) return;
        bindSortToggle(toolbar, grid);
        applySortMode(grid, 'community');
      });
    });
  </script>
</body>
</html>