<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Profile and optimize application performance">
  <title>perf-profiler - OpenClaw Directory</title>
  <link rel="canonical" href="https://moltdirectory.com/web-frontend-development/perf-profiler/">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ü¶û</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/style.css">
  <script>
    // Apply saved theme before page renders to prevent flash
    (function() {
      const savedTheme = localStorage.getItem('theme') || 'dark';
      if (savedTheme === 'light') {
        document.documentElement.setAttribute('data-theme', 'light');
      }
    })();
  </script>
</head>
<body>
  <header class="header">
    <div class="header-inner">
      <a href="/" class="logo">

        <span class="logo-text">OpenClaw Directory</span>
      </a>
      <nav class="header-links">
        <a href="/start-here/" class="header-link">Start Here</a>
        <a href="/security-auditor" class="header-link">Security Auditor</a>
        <a href="https://github.com/neonone123/moltdirectory/issues/new?template=add-skill.yml" class="header-link" target="_blank" rel="noopener">Add Skill</a>
        <button class="theme-toggle" aria-label="Toggle theme" onclick="toggleTheme()">
          <svg class="icon-moon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
          <svg class="icon-sun" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
        </button>
        <a href="https://www.reddit.com/r/OpenClawDirectory/" class="header-link" target="_blank" rel="noopener" aria-label="Community">
          <svg viewBox="0 0 16 16" fill="currentColor" width="28" height="28"><path d="M6.167 8a.83.83 0 0 0-.83.83c0 .459.372.84.83.831a.831.831 0 0 0 0-1.661m1.843 3.647c.315 0 1.403-.038 1.976-.611a.23.23 0 0 0 0-.306.213.213 0 0 0-.306 0c-.353.363-1.126.487-1.67.487-.545 0-1.308-.124-1.671-.487a.213.213 0 0 0-.306 0 .213.213 0 0 0 0 .306c.564.563 1.652.61 1.977.61zm.992-2.807c0 .458.373.83.831.83s.83-.381.83-.83a.831.831 0 0 0-1.66 0z"/><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0m-3.828-1.165c-.315 0-.602.124-.812.325-.801-.573-1.9-.945-3.121-.993l.534-2.501 1.738.372a.83.83 0 1 0 .83-.869.83.83 0 0 0-.744.468l-1.938-.41a.2.2 0 0 0-.153.028.2.2 0 0 0-.086.134l-.592 2.788c-1.24.038-2.358.41-3.17.992-.21-.2-.496-.324-.81-.324a1.163 1.163 0 0 0-.478 2.224q-.03.17-.029.353c0 1.795 2.091 3.256 4.669 3.256s4.668-1.451 4.668-3.256c0-.114-.01-.238-.029-.353.401-.181.688-.592.688-1.069 0-.65-.525-1.165-1.165-1.165"/></svg>
        </a>
      </nav>
    </div>
  </header>
  
          <section class="skill-page-header">
            <div class="skill-page-header-inner">
              <a href="/web-frontend-development/" class="back-link">‚Üê Back to Web & Frontend Development</a>
              <div class="skill-page-meta">
                <a href="/web-frontend-development/" class="skill-page-category">Web & Frontend Development</a>
                <span class="skill-page-author">by @gitgoodordietrying</span>
              </div>
              <h1 class="skill-page-title">perf-profiler</h1>
              <p class="skill-page-desc">Profile and optimize application performance</p>
              <div class="vote-widget skill-page-vote" data-category-id="web-frontend-development" data-tool-id="perf-profiler">
                <button type="button" class="vote-btn" data-vote="1" aria-label="Upvote perf-profiler">‚ñ≤</button>
                <span class="vote-count">New</span>
                <button type="button" class="vote-btn" data-vote="-1" aria-label="Downvote perf-profiler">‚ñº</button>
              </div>
            </div>
          </section>
          <div class="skill-page-body">
            <article class="skill-page-content">
              <div class="skill-source-wrapper">
                <div class="skill-source-header">
                  <div class="skill-source-title">Source Code</div>
                  <button class="copy-btn" onclick="copySkillContent(this)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
                    Copy
                  </button>
                </div>
                <div class="markdown-content">
                  <h1>Performance Profiler</h1>
<p>Measure, profile, and optimize application performance. Covers CPU profiling, memory analysis, flame graphs, benchmarking, load testing, and language-specific optimization patterns.</p>
<h2>When to Use</h2>
<ul>
<li>Diagnosing why an application or function is slow</li>
<li>Measuring CPU and memory usage</li>
<li>Generating flame graphs to visualize hot paths</li>
<li>Benchmarking functions or endpoints</li>
<li>Load testing APIs before deployment</li>
<li>Finding and fixing memory leaks</li>
<li>Optimizing database query performance</li>
<li>Comparing performance before and after changes</li>
</ul>
<h2>Quick Timing</h2>
<h3>Command-line timing</h3>
<pre><code class="language-bash"># Time any command
time my-command --flag

# More precise: multiple runs with stats
for i in $(seq 1 10); do
  /usr/bin/time -f &quot;%e&quot; my-command 2&gt;&amp;1
done | awk &#39;{sum+=$1; sumsq+=$1*$1; count++} END {
  avg=sum/count;
  stddev=sqrt(sumsq/count - avg*avg);
  printf &quot;runs=%d avg=%.3fs stddev=%.3fs\n&quot;, count, avg, stddev
}&#39;

# Hyperfine (better benchmarking tool)
# Install: https://github.com/sharkdp/hyperfine
hyperfine &#39;command-a&#39; &#39;command-b&#39;
hyperfine --warmup 3 --runs 20 &#39;my-command&#39;
hyperfine --export-json results.json &#39;old-version&#39; &#39;new-version&#39;
</code></pre>
<h3>Inline timing (any language)</h3>
<pre><code class="language-javascript">// Node.js
console.time(&#39;operation&#39;);
await doExpensiveThing();
console.timeEnd(&#39;operation&#39;); // &quot;operation: 142.3ms&quot;

// High-resolution
const start = performance.now();
await doExpensiveThing();
const elapsed = performance.now() - start;
console.log(`Elapsed: ${elapsed.toFixed(2)}ms`);
</code></pre>
<pre><code class="language-python"># Python
import time

start = time.perf_counter()
do_expensive_thing()
elapsed = time.perf_counter() - start
print(f&quot;Elapsed: {elapsed:.4f}s&quot;)

# Context manager
from contextlib import contextmanager

@contextmanager
def timer(label=&quot;&quot;):
    start = time.perf_counter()
    yield
    elapsed = time.perf_counter() - start
    print(f&quot;{label}: {elapsed:.4f}s&quot;)

with timer(&quot;data processing&quot;):
    process_data()
</code></pre>
<pre><code class="language-go">// Go
start := time.Now()
doExpensiveThing()
fmt.Printf(&quot;Elapsed: %v\n&quot;, time.Since(start))
</code></pre>
<h2>Node.js Profiling</h2>
<h3>CPU profiling with V8 inspector</h3>
<pre><code class="language-bash"># Generate CPU profile (writes .cpuprofile file)
node --cpu-prof app.js
# Open the .cpuprofile in Chrome DevTools &gt; Performance tab

# Profile for a specific duration
node --cpu-prof --cpu-prof-interval=100 app.js

# Inspect running process
node --inspect app.js
# Open chrome://inspect in Chrome, click &quot;inspect&quot;
# Go to Performance tab, click Record
</code></pre>
<h3>Heap snapshots (memory)</h3>
<pre><code class="language-bash"># Generate heap snapshot
node --heap-prof app.js

# Take snapshots programmatically
node -e &quot;
const v8 = require(&#39;v8&#39;);
const fs = require(&#39;fs&#39;);

// Take snapshot
const snapshotStream = v8.writeHeapSnapshot();
console.log(&#39;Heap snapshot written to:&#39;, snapshotStream);
&quot;

# Compare heap snapshots to find leaks:
# 1. Take snapshot A (baseline)
# 2. Run operations that might leak
# 3. Take snapshot B
# 4. In Chrome DevTools &gt; Memory, load both and use &quot;Comparison&quot; view
</code></pre>
<h3>Memory usage monitoring</h3>
<pre><code class="language-javascript">// Print memory usage periodically
setInterval(() =&gt; {
  const usage = process.memoryUsage();
  console.log({
    rss: `${(usage.rss / 1024 / 1024).toFixed(1)}MB`,
    heapUsed: `${(usage.heapUsed / 1024 / 1024).toFixed(1)}MB`,
    heapTotal: `${(usage.heapTotal / 1024 / 1024).toFixed(1)}MB`,
    external: `${(usage.external / 1024 / 1024).toFixed(1)}MB`,
  });
}, 5000);

// Detect memory growth
let lastHeap = 0;
setInterval(() =&gt; {
  const heap = process.memoryUsage().heapUsed;
  const delta = heap - lastHeap;
  if (delta &gt; 1024 * 1024) { // &gt; 1MB growth
    console.warn(`Heap grew by ${(delta / 1024 / 1024).toFixed(1)}MB`);
  }
  lastHeap = heap;
}, 10000);
</code></pre>
<h3>Node.js benchmarking</h3>
<pre><code class="language-javascript">// Simple benchmark function
function benchmark(name, fn, iterations = 10000) {
  // Warmup
  for (let i = 0; i &lt; 100; i++) fn();

  const start = performance.now();
  for (let i = 0; i &lt; iterations; i++) fn();
  const elapsed = performance.now() - start;

  console.log(`${name}: ${(elapsed / iterations).toFixed(4)}ms/op (${iterations} iterations in ${elapsed.toFixed(1)}ms)`);
}

benchmark(&#39;JSON.parse&#39;, () =&gt; JSON.parse(&#39;{&quot;key&quot;:&quot;value&quot;,&quot;num&quot;:42}&#39;));
benchmark(&#39;regex match&#39;, () =&gt; /^\d{4}-\d{2}-\d{2}$/.test(&#39;2026-02-03&#39;));
</code></pre>
<h2>Python Profiling</h2>
<h3>cProfile (built-in CPU profiler)</h3>
<pre><code class="language-bash"># Profile a script
python3 -m cProfile -s cumulative my_script.py

# Save to file for analysis
python3 -m cProfile -o profile.prof my_script.py

# Analyze saved profile
python3 -c &quot;
import pstats
stats = pstats.Stats(&#39;profile.prof&#39;)
stats.sort_stats(&#39;cumulative&#39;)
stats.print_stats(20)
&quot;

# Profile a specific function
python3 -c &quot;
import cProfile
from my_module import expensive_function

cProfile.run(&#39;expensive_function()&#39;, sort=&#39;cumulative&#39;)
&quot;
</code></pre>
<h3>line_profiler (line-by-line)</h3>
<pre><code class="language-bash"># Install
pip install line_profiler

# Add @profile decorator to functions of interest, then:
kernprof -l -v my_script.py
</code></pre>
<pre><code class="language-python"># Programmatic usage
from line_profiler import LineProfiler

def process_data(data):
    result = []
    for item in data:           # Is this loop the bottleneck?
        transformed = transform(item)
        if validate(transformed):
            result.append(transformed)
    return result

profiler = LineProfiler()
profiler.add_function(process_data)
profiler.enable()
process_data(large_dataset)
profiler.disable()
profiler.print_stats()
</code></pre>
<h3>Memory profiling (Python)</h3>
<pre><code class="language-bash"># memory_profiler
pip install memory_profiler

# Profile memory line-by-line
python3 -m memory_profiler my_script.py
</code></pre>
<pre><code class="language-python">from memory_profiler import profile

@profile
def load_data():
    data = []
    for i in range(1000000):
        data.append({&#39;id&#39;: i, &#39;value&#39;: f&#39;item_{i}&#39;})
    return data

# Track memory over time
import tracemalloc

tracemalloc.start()

# ... run code ...

snapshot = tracemalloc.take_snapshot()
top_stats = snapshot.statistics(&#39;lineno&#39;)
for stat in top_stats[:10]:
    print(stat)
</code></pre>
<h3>Python benchmarking</h3>
<pre><code class="language-python">import timeit

# Time a statement
result = timeit.timeit(&#39;sorted(range(1000))&#39;, number=10000)
print(f&quot;sorted: {result:.4f}s for 10000 iterations&quot;)

# Compare two approaches
setup = &quot;data = list(range(10000))&quot;
t1 = timeit.timeit(&#39;list(filter(lambda x: x % 2 == 0, data))&#39;, setup=setup, number=1000)
t2 = timeit.timeit(&#39;[x for x in data if x % 2 == 0]&#39;, setup=setup, number=1000)
print(f&quot;filter: {t1:.4f}s  |  listcomp: {t2:.4f}s  |  speedup: {t1/t2:.2f}x&quot;)

# pytest-benchmark
# pip install pytest-benchmark
# def test_sort(benchmark):
#     benchmark(sorted, list(range(1000)))
</code></pre>
<h2>Go Profiling</h2>
<h3>Built-in pprof</h3>
<pre><code class="language-go">// Add to main.go for HTTP-accessible profiling
import (
    &quot;net/http&quot;
    _ &quot;net/http/pprof&quot;
)

func main() {
    go func() {
        http.ListenAndServe(&quot;localhost:6060&quot;, nil)
    }()
    // ... rest of app
}
</code></pre>
<pre><code class="language-bash"># CPU profile (30 seconds)
go tool pprof http://localhost:6060/debug/pprof/profile?seconds=30

# Memory profile
go tool pprof http://localhost:6060/debug/pprof/heap

# Goroutine profile
go tool pprof http://localhost:6060/debug/pprof/goroutine

# Inside pprof interactive mode:
# top 20          - top functions by CPU/memory
# list funcName   - source code with annotations
# web             - open flame graph in browser
# png &gt; out.png   - save call graph as image
</code></pre>
<h3>Go benchmarks</h3>
<pre><code class="language-go">// math_test.go
func BenchmarkAdd(b *testing.B) {
    for i := 0; i &lt; b.N; i++ {
        Add(42, 58)
    }
}

func BenchmarkSort1000(b *testing.B) {
    data := make([]int, 1000)
    for i := range data {
        data[i] = rand.Intn(1000)
    }
    b.ResetTimer()
    for i := 0; i &lt; b.N; i++ {
        sort.Ints(append([]int{}, data...))
    }
}
</code></pre>
<pre><code class="language-bash"># Run benchmarks
go test -bench=. -benchmem ./...

# Compare before/after
go test -bench=. -count=5 ./... &gt; old.txt
# ... make changes ...
go test -bench=. -count=5 ./... &gt; new.txt
go install golang.org/x/perf/cmd/benchstat@latest
benchstat old.txt new.txt
</code></pre>
<h2>Flame Graphs</h2>
<h3>Generate flame graphs</h3>
<pre><code class="language-bash"># Node.js: 0x (easiest)
npx 0x app.js
# Opens interactive flame graph in browser

# Node.js: clinic.js (comprehensive)
npx clinic flame -- node app.js
npx clinic doctor -- node app.js
npx clinic bubbleprof -- node app.js

# Python: py-spy (sampling profiler, no code changes needed)
pip install py-spy
py-spy record -o flame.svg -- python3 my_script.py

# Profile running Python process
py-spy record -o flame.svg --pid 12345

# Go: built-in
go tool pprof -http=:8080 http://localhost:6060/debug/pprof/profile?seconds=30
# Navigate to &quot;Flame Graph&quot; view

# Linux (any process): perf + flamegraph
perf record -g -p PID -- sleep 30
perf script | stackcollapse-perf.pl | flamegraph.pl &gt; flame.svg
</code></pre>
<h3>Reading flame graphs</h3>
<pre><code>Key concepts:
- X-axis: NOT time. It&#39;s alphabetical sort of stack frames. Width = % of samples.
- Y-axis: Stack depth. Top = leaf function (where CPU time is spent).
- Wide bars at the top = hot functions (optimize these first).
- Narrow tall stacks = deep call chains (may indicate excessive abstraction).

What to look for:
1. Wide plateaus at the top ‚Üí function that dominates CPU time
2. Multiple paths converging to one function ‚Üí shared bottleneck
3. GC/runtime frames taking significant width ‚Üí memory pressure
4. Unexpected functions appearing wide ‚Üí performance bug
</code></pre>
<h2>Load Testing</h2>
<h3>curl-based quick test</h3>
<pre><code class="language-bash"># Single request timing
curl -o /dev/null -s -w &quot;HTTP %{http_code} | Total: %{time_total}s | TTFB: %{time_starttransfer}s | Connect: %{time_connect}s\n&quot; https://api.example.com/endpoint

# Multiple requests in sequence
for i in $(seq 1 20); do
  curl -o /dev/null -s -w &quot;%{time_total}\n&quot; https://api.example.com/endpoint
done | awk &#39;{sum+=$1; count++; if($1&gt;max)max=$1} END {printf &quot;avg=%.3fs max=%.3fs n=%d\n&quot;, sum/count, max, count}&#39;
</code></pre>
<h3>Apache Bench (ab)</h3>
<pre><code class="language-bash"># 100 requests, 10 concurrent
ab -n 100 -c 10 http://localhost:3000/api/endpoint

# With POST data
ab -n 100 -c 10 -p data.json -T application/json http://localhost:3000/api/endpoint

# Key metrics to watch:
# - Requests per second (throughput)
# - Time per request (latency)
# - Percentage of requests served within a certain time (p50, p90, p99)
</code></pre>
<h3>wrk (modern load testing)</h3>
<pre><code class="language-bash"># Install: https://github.com/wg/wrk
# 10 seconds, 4 threads, 100 connections
wrk -t4 -c100 -d10s http://localhost:3000/api/endpoint

# With Lua script for custom requests
wrk -t4 -c100 -d10s -s post.lua http://localhost:3000/api/endpoint
</code></pre>
<pre><code class="language-lua">-- post.lua
wrk.method = &quot;POST&quot;
wrk.body   = &#39;{&quot;key&quot;: &quot;value&quot;}&#39;
wrk.headers[&quot;Content-Type&quot;] = &quot;application/json&quot;

-- Custom request generation
request = function()
  local id = math.random(1, 10000)
  local path = &quot;/api/users/&quot; .. id
  return wrk.format(&quot;GET&quot;, path)
end
</code></pre>
<h3>Autocannon (Node.js load testing)</h3>
<pre><code class="language-bash">npx autocannon -c 100 -d 10 http://localhost:3000/api/endpoint
npx autocannon -c 100 -d 10 -m POST -b &#39;{&quot;key&quot;:&quot;value&quot;}&#39; -H &#39;Content-Type=application/json&#39; http://localhost:3000/api/endpoint
</code></pre>
<h2>Database Query Performance</h2>
<h3>EXPLAIN analysis</h3>
<pre><code class="language-bash"># PostgreSQL
psql -c &quot;EXPLAIN (ANALYZE, BUFFERS, FORMAT TEXT) SELECT * FROM orders WHERE user_id = 123;&quot;

# MySQL
mysql -e &quot;EXPLAIN SELECT * FROM orders WHERE user_id = 123;&quot; mydb

# SQLite
sqlite3 mydb.sqlite &quot;EXPLAIN QUERY PLAN SELECT * FROM orders WHERE user_id = 123;&quot;
</code></pre>
<h3>Slow query detection</h3>
<pre><code class="language-bash"># PostgreSQL: enable slow query logging
# In postgresql.conf:
# log_min_duration_statement = 100  (ms)

# MySQL: slow query log
# In my.cnf:
# slow_query_log = 1
# long_query_time = 0.1

# Find queries missing indexes (PostgreSQL)
psql -c &quot;
SELECT schemaname, relname, seq_scan, seq_tup_read,
       idx_scan, idx_tup_fetch,
       seq_tup_read / GREATEST(seq_scan, 1) AS avg_rows_per_scan
FROM pg_stat_user_tables
WHERE seq_scan &gt; 100 AND seq_tup_read / GREATEST(seq_scan, 1) &gt; 1000
ORDER BY seq_tup_read DESC
LIMIT 10;
&quot;
</code></pre>
<h2>Memory Leak Detection Patterns</h2>
<h3>Node.js</h3>
<pre><code class="language-javascript">// Track object counts over time
const v8 = require(&#39;v8&#39;);

function checkMemory() {
  const heap = v8.getHeapStatistics();
  const usage = process.memoryUsage();
  return {
    heapUsedMB: (usage.heapUsed / 1024 / 1024).toFixed(1),
    heapTotalMB: (usage.heapTotal / 1024 / 1024).toFixed(1),
    rssMB: (usage.rss / 1024 / 1024).toFixed(1),
    externalMB: (usage.external / 1024 / 1024).toFixed(1),
    arrayBuffersMB: (usage.arrayBuffers / 1024 / 1024).toFixed(1),
  };
}

// Sample every 10s, alert on growth
let baseline = process.memoryUsage().heapUsed;
setInterval(() =&gt; {
  const current = process.memoryUsage().heapUsed;
  const growthMB = (current - baseline) / 1024 / 1024;
  if (growthMB &gt; 50) {
    console.warn(`Memory grew ${growthMB.toFixed(1)}MB since start`);
    console.warn(checkMemory());
  }
}, 10000);
</code></pre>
<h3>Common leak patterns</h3>
<pre><code>Node.js:
- Event listeners not removed (emitter.on without emitter.off)
- Closures capturing large objects in long-lived scopes
- Global caches without eviction (Map/Set that only grows)
- Unresolved promises accumulating

Python:
- Circular references (use weakref for caches)
- Global lists/dicts that grow unbounded
- File handles not closed (use context managers)
- C extension objects not properly freed

Go:
- Goroutine leaks (goroutine started, never returns)
- Forgotten channel listeners
- Unclosed HTTP response bodies
- Global maps that grow forever
</code></pre>
<h2>Performance Comparison Script</h2>
<pre><code class="language-bash">#!/bin/bash
# perf-compare.sh - Compare performance before/after a change
# Usage: perf-compare.sh &lt;command&gt; [runs]
CMD=&quot;${1:?Usage: perf-compare.sh &lt;command&gt; [runs]}&quot;
RUNS=&quot;${2:-10}&quot;

echo &quot;Benchmarking: $CMD&quot;
echo &quot;Runs: $RUNS&quot;
echo &quot;&quot;

times=()
for i in $(seq 1 &quot;$RUNS&quot;); do
  start=$(date +%s%N)
  eval &quot;$CMD&quot; &gt; /dev/null 2&gt;&amp;1
  end=$(date +%s%N)
  elapsed=$(echo &quot;scale=3; ($end - $start) / 1000000&quot; | bc)
  times+=(&quot;$elapsed&quot;)
  printf &quot;  Run %2d: %sms\n&quot; &quot;$i&quot; &quot;$elapsed&quot;
done

echo &quot;&quot;
printf &#39;%s\n&#39; &quot;${times[@]}&quot; | awk &#39;{
  sum += $1
  sumsq += $1 * $1
  if (NR == 1 || $1 &lt; min) min = $1
  if (NR == 1 || $1 &gt; max) max = $1
  count++
} END {
  avg = sum / count
  stddev = sqrt(sumsq/count - avg*avg)
  printf &quot;Results: avg=%.1fms min=%.1fms max=%.1fms stddev=%.1fms (n=%d)\n&quot;, avg, min, max, stddev, count
}&#39;
</code></pre>
<h2>Tips</h2>
<ul>
<li><strong>Profile before optimizing.</strong> Guessing where bottlenecks are is wrong more often than right. Measure first.</li>
<li><strong>Optimize the hot path.</strong> Flame graphs show you exactly which functions consume the most time. A 10% improvement in a function that takes 80% of CPU time is worth more than a 50% improvement in one that takes 2%.</li>
<li><strong>Memory and CPU are different problems.</strong> A memory leak can exist in fast code. A CPU bottleneck can exist in code with stable memory. Profile both independently.</li>
<li><strong>Benchmark under realistic conditions.</strong> Microbenchmarks (empty loops, single-function timing) can be misleading due to JIT optimization, caching, and branch prediction. Use realistic data and workloads.</li>
<li><strong>p99 matters more than average.</strong> An API with 50ms average but 2s p99 has a tail latency problem. Always look at percentiles, not just averages.</li>
<li><strong>Load test before shipping.</strong> <code>ab</code>, <code>wrk</code>, or <code>autocannon</code> for 60 seconds at expected peak traffic reveals problems that unit tests never will.</li>
<li><strong>GC pauses are real.</strong> In Node.js, Python, Go, and Java, garbage collection can cause latency spikes. If flame graphs show significant GC time, reduce allocation pressure (reuse objects, use object pools, avoid unnecessary copies).</li>
<li><strong>Database queries are usually the bottleneck.</strong> Before optimizing application code, run <code>EXPLAIN</code> on your slowest queries. An index can turn a 2-second query into 2ms.</li>
</ul>

                </div>
              </div>
            </article>
            <aside class="skill-page-sidebar">
              <div class="sidebar-card">
                <div class="sidebar-title">Actions</div>
                <a href="https://github.com/openclaw/skills/tree/main/skills/gitgoodordietrying/perf-profiler/SKILL.md" target="_blank" rel="noopener" class="sidebar-btn sidebar-btn-primary">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/></svg>
                  View on GitHub
                </a>
                <a href="https://clawdhub.com/gitgoodordietrying/perf-profiler" target="_blank" rel="noopener" class="sidebar-btn sidebar-btn-clawdhub">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/><line x1="2" y1="12" x2="22" y2="12"/></svg>
                  View on ClawdHub
                </a>
                <a href="https://raw.githubusercontent.com/openclaw/skills/main/skills/gitgoodordietrying/perf-profiler/SKILL.md" download="SKILL.md" class="sidebar-btn sidebar-btn-secondary">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                  Download SKILL.md
                </a>
                <button onclick="sendToSecurityAuditor()" class="sidebar-btn sidebar-btn-security">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>
                  Security Check
                </button>
              </div>
              <div class="sidebar-card">
                <div class="sidebar-title">Details</div>
                <div class="sidebar-info">
                  <div class="sidebar-info-item">
                    <span class="sidebar-info-label">Author</span>
                    <span class="sidebar-info-value">@gitgoodordietrying</span>
                  </div>
                  <div class="sidebar-info-item">
                    <span class="sidebar-info-label">Category</span>
                    <span class="sidebar-info-value">Web & Frontend Development</span>
                  </div>
                </div>
              </div>
            </aside>
          </div>
        
  <footer class="footer">
    <div class="footer-inner">
      <p class="footer-text" style="margin-bottom: 8px;"><a href="https://github.com/neonone123/moltdirectory" target="_blank" rel="noopener" style="color: var(--accent); text-decoration: none;">View on GitHub</a></p>
      <p class="footer-text" style="opacity: 0.6; font-size: 13px;">OpenClawDirectory.com is a community-run project and is not affiliated with the official OpenClaw team or Peter Steinberger. We are just fans of the lobster.</p>
    </div>
  </footer>
  <script>
    function toggleTheme() {
      const html = document.documentElement;
      const currentTheme = html.getAttribute('data-theme');
      const newTheme = currentTheme === 'light' ? 'dark' : 'light';
      if (newTheme === 'light') {
        html.setAttribute('data-theme', 'light');
      } else {
        html.removeAttribute('data-theme');
      }
      localStorage.setItem('theme', newTheme);
    }
    
    function copySkillContent(btn) {
      const wrapper = btn.closest('.skill-source-wrapper');
      const content = wrapper.querySelector('.markdown-content');
      if (content) {
        const text = content.innerText || content.textContent;
        navigator.clipboard.writeText(text).then(() => {
          btn.classList.add('copied');
          btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg> Copied!';
          setTimeout(() => {
            btn.classList.remove('copied');
            btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg> Copy';
          }, 2000);
        });
      }
    }

    async function sendToSecurityAuditor() {
      try {
        const contentElement = document.querySelector('.markdown-content');
        if (!contentElement) throw new Error('Could not find markdown content');
        const skillContent = contentElement.innerText || contentElement.textContent;
        localStorage.setItem('skillAuditContent', skillContent);
        window.open('/security-auditor', '_blank'); 
      } catch (error) {
        alert('Error: ' + error.message);
      }
    }

    function updateVoteWidget(widget, toolData) {
      if (!widget || !toolData) return;
      const upBtn = widget.querySelector('[data-vote="1"]');
      const downBtn = widget.querySelector('[data-vote="-1"]');
      const countNode = widget.querySelector('.vote-count');
      widget.dataset.rankScore = String(toolData.rankScore ?? 0);
      widget.dataset.viewerVote = String(toolData.viewerVote ?? 0);

      if (countNode) {
        countNode.textContent = toolData.displayCount || 'New';
      }
      if (upBtn) {
        upBtn.classList.toggle('is-active', Number(toolData.viewerVote) === 1);
      }
      if (downBtn) {
        downBtn.classList.toggle('is-active', Number(toolData.viewerVote) === -1);
      }
    }

    function setWidgetBusy(widget, busy) {
      widget.dataset.busy = busy ? '1' : '0';
      widget.querySelectorAll('.vote-btn').forEach((btn) => {
        btn.disabled = busy;
      });
    }

    function applySortMode(grid, mode) {
      const cards = [...grid.querySelectorAll('.skill-card[data-tool-id]')];
      cards.sort((a, b) => {
        if (mode === 'community') {
          const scoreDiff = Number(b.dataset.rankScore || 0) - Number(a.dataset.rankScore || 0);
          if (scoreDiff !== 0) return scoreDiff;
        }
        return Number(a.dataset.originalIndex || 0) - Number(b.dataset.originalIndex || 0);
      });
      cards.forEach((card) => grid.appendChild(card));
    }

    function bindSortToggle(toolbar, grid) {
      const buttons = toolbar.querySelectorAll('.sort-toggle-btn');
      const status = toolbar.querySelector('.sort-status');
      buttons.forEach((btn) => {
        btn.addEventListener('click', () => {
          const mode = btn.dataset.sortMode;
          buttons.forEach((b) => b.classList.toggle('is-active', b === btn));
          applySortMode(grid, mode);
          status.textContent = mode === 'community' ? 'Community ranking active' : 'Original order active';
        });
      });
    }

    async function fetchScores(categoryId, toolIds) {
      const params = new URLSearchParams({
        categoryId,
        toolIds: toolIds.join(',')
      });
      const response = await fetch('/api/v1/scores?' + params.toString(), {
        method: 'GET',
        credentials: 'same-origin'
      });
      if (!response.ok) {
        throw new Error('Unable to fetch vote scores');
      }
      return response.json();
    }

    async function submitVote(widget, voteValue) {
      const categoryId = widget.dataset.categoryId;
      const toolId = widget.dataset.toolId;
      setWidgetBusy(widget, true);
      try {
        const response = await fetch('/api/v1/vote', {
          method: 'POST',
          credentials: 'same-origin',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            categoryId,
            toolId,
            vote: voteValue
          })
        });
        const payload = await response.json().catch(() => ({}));
        if (!response.ok) {
          throw new Error(payload.error || 'Vote request failed');
        }
        if (payload.tool) {
          updateVoteWidget(widget, payload.tool);
          const card = widget.closest('.skill-card[data-tool-id]');
          if (card) {
            card.dataset.rankScore = String(payload.tool.rankScore ?? 0);
          }
        }
      } catch (error) {
        console.error(error);
      } finally {
        setWidgetBusy(widget, false);
      }
    }

    document.addEventListener('DOMContentLoaded', async () => {
      const widgets = [...document.querySelectorAll('.vote-widget[data-category-id][data-tool-id]')];
      if (widgets.length === 0) return;

      const grouped = new Map();
      widgets.forEach((widget) => {
        const key = widget.dataset.categoryId;
        if (!grouped.has(key)) grouped.set(key, new Map());
        grouped.get(key).set(widget.dataset.toolId, widget);
      });

      for (const [categoryId, widgetMap] of grouped.entries()) {
        const toolIds = [...widgetMap.keys()];
        try {
          const data = await fetchScores(categoryId, toolIds);
          const byTool = new Map((data.tools || []).map((tool) => [tool.toolId, tool]));
          for (const [toolId, widget] of widgetMap.entries()) {
            const toolData = byTool.get(toolId);
            if (toolData) {
              updateVoteWidget(widget, toolData);
              const card = widget.closest('.skill-card[data-tool-id]');
              if (card) {
                card.dataset.rankScore = String(toolData.rankScore ?? 0);
              }
            }
          }
        } catch (error) {
          console.error(error);
        }
      }

      widgets.forEach((widget) => {
        widget.querySelectorAll('.vote-btn').forEach((btn) => {
          btn.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            if (widget.dataset.busy === '1') return;
            const voteValue = Number(btn.dataset.vote);
            submitVote(widget, voteValue).then(() => {
              const grid = widget.closest('.skills-grid[data-category-id]');
              const toolbar = document.querySelector('.sort-toolbar[data-category-id="' + widget.dataset.categoryId + '"]');
              const communityBtn = toolbar ? toolbar.querySelector('.sort-toggle-btn[data-sort-mode="community"]') : null;
              if (grid && communityBtn && communityBtn.classList.contains('is-active')) {
                applySortMode(grid, 'community');
              }
            });
          });
        });
      });

      document.querySelectorAll('.skills-grid[data-category-id]').forEach((grid) => {
        const categoryId = grid.dataset.categoryId;
        const toolbar = document.querySelector('.sort-toolbar[data-category-id="' + categoryId + '"]');
        if (!toolbar) return;
        bindSortToggle(toolbar, grid);
        applySortMode(grid, 'community');
      });
    });
  </script>
</body>
</html>