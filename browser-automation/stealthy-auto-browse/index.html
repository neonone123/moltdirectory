<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Control a stealthy browser that evades bot detection">
  <title>stealthy-auto-browse - OpenClaw Directory</title>
  <link rel="canonical" href="https://moltdirectory.com/browser-automation/stealthy-auto-browse/">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ü¶û</text></svg>">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/style.css">
  <script>
    // Apply saved theme before page renders to prevent flash
    (function() {
      const savedTheme = localStorage.getItem('theme') || 'dark';
      if (savedTheme === 'light') {
        document.documentElement.setAttribute('data-theme', 'light');
      }
    })();
  </script>
</head>
<body>
  <header class="header">
    <div class="header-inner">
      <a href="/" class="logo">

        <span class="logo-text">OpenClaw Directory</span>
      </a>
      <nav class="header-links">
        <a href="/start-here/" class="header-link">Start Here</a>
        <a href="/security-auditor" class="header-link">Security Auditor</a>
        <a href="https://github.com/neonone123/moltdirectory/issues/new?template=add-skill.yml" class="header-link" target="_blank" rel="noopener">Add Skill</a>
        <button class="theme-toggle" aria-label="Toggle theme" onclick="toggleTheme()">
          <svg class="icon-moon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/></svg>
          <svg class="icon-sun" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>
        </button>
        <a href="https://www.reddit.com/r/OpenClawDirectory/" class="header-link" target="_blank" rel="noopener" aria-label="Community">
          <svg viewBox="0 0 16 16" fill="currentColor" width="28" height="28"><path d="M6.167 8a.83.83 0 0 0-.83.83c0 .459.372.84.83.831a.831.831 0 0 0 0-1.661m1.843 3.647c.315 0 1.403-.038 1.976-.611a.23.23 0 0 0 0-.306.213.213 0 0 0-.306 0c-.353.363-1.126.487-1.67.487-.545 0-1.308-.124-1.671-.487a.213.213 0 0 0-.306 0 .213.213 0 0 0 0 .306c.564.563 1.652.61 1.977.61zm.992-2.807c0 .458.373.83.831.83s.83-.381.83-.83a.831.831 0 0 0-1.66 0z"/><path d="M16 8A8 8 0 1 1 0 8a8 8 0 0 1 16 0m-3.828-1.165c-.315 0-.602.124-.812.325-.801-.573-1.9-.945-3.121-.993l.534-2.501 1.738.372a.83.83 0 1 0 .83-.869.83.83 0 0 0-.744.468l-1.938-.41a.2.2 0 0 0-.153.028.2.2 0 0 0-.086.134l-.592 2.788c-1.24.038-2.358.41-3.17.992-.21-.2-.496-.324-.81-.324a1.163 1.163 0 0 0-.478 2.224q-.03.17-.029.353c0 1.795 2.091 3.256 4.669 3.256s4.668-1.451 4.668-3.256c0-.114-.01-.238-.029-.353.401-.181.688-.592.688-1.069 0-.65-.525-1.165-1.165-1.165"/></svg>
        </a>
      </nav>
    </div>
  </header>
  
          <section class="skill-page-header">
            <div class="skill-page-header-inner">
              <a href="/browser-automation/" class="back-link">‚Üê Back to Browser & Automation</a>
              <div class="skill-page-meta">
                <a href="/browser-automation/" class="skill-page-category">Browser & Automation</a>
                <span class="skill-page-author">by @psyb0t</span>
              </div>
              <h1 class="skill-page-title">stealthy-auto-browse</h1>
              <p class="skill-page-desc">Control a stealthy browser that evades bot detection</p>
              <div class="vote-widget skill-page-vote" data-category-id="browser-automation" data-tool-id="stealthy-auto-browse">
                <button type="button" class="vote-btn" data-vote="1" aria-label="Upvote stealthy-auto-browse">‚ñ≤</button>
                <span class="vote-count">New</span>
                <button type="button" class="vote-btn" data-vote="-1" aria-label="Downvote stealthy-auto-browse">‚ñº</button>
              </div>
            </div>
          </section>
          <div class="skill-page-body">
            <article class="skill-page-content">
              <div class="skill-source-wrapper">
                <div class="skill-source-header">
                  <div class="skill-source-title">Source Code</div>
                  <button class="copy-btn" onclick="copySkillContent(this)">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg>
                    Copy
                  </button>
                </div>
                <div class="markdown-content">
                  <h1>stealthy-auto-browse</h1>
<p>A stealth browser running in Docker. It uses Camoufox (a custom Firefox fork) instead of Chromium, so there are zero Chrome DevTools Protocol (CDP) signals for bot detectors to find. Mouse and keyboard input happens at the OS level via PyAutoGUI ‚Äî the browser itself doesn&#39;t know it&#39;s being automated, which means behavioral analysis can&#39;t detect it either.</p>
<h2>Why This Exists</h2>
<p>Standard browser automation (Playwright + Chromium, Puppeteer, Selenium) exposes CDP signals that bot detection services (Cloudflare, DataDome, PerimeterX, Akamai) catch instantly. Even with stealth plugins, the CDP protocol is still there and detectable. This skill eliminates that entirely by using Firefox (no CDP at all) and generating input events at the OS level rather than through the browser&#39;s automation API.</p>
<h2>When To Use This Skill</h2>
<ul>
<li>Site has bot detection (Cloudflare challenge pages, DataDome, PerimeterX, Akamai)</li>
<li>Site blocks headless browsers or serves CAPTCHAs</li>
<li>You need a logged-in session that doesn&#39;t get banned</li>
<li>Another browser skill is getting 403s or empty/blocked responses</li>
<li>You&#39;re scraping a site that actively fights automation</li>
</ul>
<h2>When NOT To Use This Skill</h2>
<ul>
<li>Simple fetches with no bot protection ‚Äî use <code>curl</code> or <code>WebFetch</code></li>
<li>Sites that don&#39;t care about automation ‚Äî use a regular browser skill, it&#39;s faster to set up</li>
<li>You only need static HTML ‚Äî use <code>curl</code></li>
</ul>
<h2>Setup</h2>
<p><strong>1. Start the container:</strong></p>
<pre><code class="language-bash">docker run -d -p 8080:8080 -p 5900:5900 psyb0t/stealthy-auto-browse
</code></pre>
<p>Port 8080 is the HTTP API. Port 5900 is a noVNC web viewer where you can watch the browser in real time.</p>
<p><strong>2. Set the environment variable:</strong></p>
<pre><code class="language-bash">export STEALTHY_AUTO_BROWSE_URL=http://localhost:8080
</code></pre>
<p>Or via OpenClaw config (<code>~/.openclaw/openclaw.json</code>):</p>
<pre><code class="language-json">{
  &quot;skills&quot;: {
    &quot;entries&quot;: {
      &quot;stealthy-auto-browse&quot;: {
        &quot;env&quot;: {
          &quot;STEALTHY_AUTO_BROWSE_URL&quot;: &quot;http://localhost:8080&quot;
        }
      }
    }
  }
}
</code></pre>
<p><strong>3. Verify:</strong> <code>curl $STEALTHY_AUTO_BROWSE_URL/health</code> returns <code>ok</code> when the browser is ready.</p>
<h2>How It Works</h2>
<p>The container runs a virtual X display (Xvfb at 1920x1080), the Camoufox browser, and an HTTP API server. You send JSON commands to the API and get JSON responses back. All commands go to <code>POST $STEALTHY_AUTO_BROWSE_URL/</code> with <code>{&quot;action&quot;: &quot;&lt;name&gt;&quot;, ...params}</code>.</p>
<p>Every response has this shape:</p>
<pre><code class="language-json">{
  &quot;success&quot;: true,
  &quot;timestamp&quot;: 1234567890.123,
  &quot;data&quot;: { ... },
  &quot;error&quot;: &quot;only present when success is false&quot;
}
</code></pre>
<p>The <code>data</code> field contents vary by action ‚Äî documented below for each one.</p>
<h2>Understanding the Two Input Modes</h2>
<p>This is the most important concept. There are two ways to interact with pages:</p>
<h3>System Input (Undetectable)</h3>
<p>Actions: <code>system_click</code>, <code>mouse_move</code>, <code>mouse_click</code>, <code>system_type</code>, <code>send_key</code>, <code>scroll</code></p>
<p>These use PyAutoGUI to generate real OS-level mouse movements and keystrokes. The browser receives these as genuine user input ‚Äî there is no way for any website JavaScript to distinguish these from a real human. <strong>Use these for stealth.</strong></p>
<p>System input works with <strong>viewport coordinates</strong> (x, y pixel positions within the browser content area). Get these coordinates from <code>get_interactive_elements</code>.</p>
<h3>Playwright Input (Detectable)</h3>
<p>Actions: <code>click</code>, <code>fill</code>, <code>type</code></p>
<p>These use Playwright&#39;s DOM automation to interact with elements by CSS selector or XPath. They&#39;re faster and more reliable (no coordinate math), but they inject events through the browser&#39;s automation layer. Sophisticated behavioral analysis can potentially detect the timing patterns. <strong>Use these when speed matters more than stealth, or when you have a selector but no coordinates.</strong></p>
<h3>When to Use Which</h3>
<ul>
<li><strong>Stealth-critical sites</strong> (Cloudflare, login forms, anything with bot detection): Always use system input.</li>
<li><strong>Simple scraping</strong> where the site isn&#39;t actively fighting you: Playwright input is fine and easier.</li>
<li><strong>Form filling</strong>: Use <code>system_click</code> to focus the field, then <code>system_type</code> to enter text. This is undetectable. Using <code>fill</code> is faster but detectable.</li>
<li><strong>Clicking buttons</strong>: If you have coordinates from <code>get_interactive_elements</code>, use <code>system_click</code>. If you only have a CSS selector, use <code>click</code>.</li>
</ul>
<h2>Workflow</h2>
<p>This is the typical sequence for interacting with a page:</p>
<ol>
<li><strong>Navigate</strong>: <code>goto</code> to load the URL</li>
<li><strong>Read the page</strong>: <code>get_text</code> returns all visible text ‚Äî usually enough to understand the page</li>
<li><strong>If text isn&#39;t clear</strong>: <code>get_html</code> gives you the full DOM structure</li>
<li><strong>If still confused</strong>: Take a screenshot (<code>GET /screenshot/browser?whLargest=512</code>)</li>
<li><strong>Find interactive elements</strong>: <code>get_interactive_elements</code> returns all buttons, links, inputs with their x,y coordinates</li>
<li><strong>Interact</strong>: <code>system_click</code> to click, <code>system_type</code> to type, <code>send_key</code> for Enter/Tab/Escape</li>
<li><strong>Wait for results</strong>: <code>wait_for_element</code> or <code>wait_for_text</code> instead of sleeping</li>
<li><strong>Verify</strong>: <code>get_text</code> again to confirm the page changed as expected</li>
</ol>
<h2>Actions Reference</h2>
<h3>Navigation</h3>
<h4>goto</h4>
<p>Navigates to a URL. This is how you load pages.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;goto&quot;, &quot;url&quot;: &quot;https://example.com&quot;}
{&quot;action&quot;: &quot;goto&quot;, &quot;url&quot;: &quot;https://example.com&quot;, &quot;wait_until&quot;: &quot;networkidle&quot;}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>url</code> (required): The URL to navigate to.</li>
<li><code>wait_until</code> (optional, default <code>&quot;domcontentloaded&quot;</code>): When to consider the page loaded. Options: <code>&quot;domcontentloaded&quot;</code> (DOM parsed, fast), <code>&quot;load&quot;</code> (all resources loaded), <code>&quot;networkidle&quot;</code> (no network activity for 500ms, slowest but most complete).</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;url&quot;: &quot;https://example.com/&quot;, &quot;title&quot;: &quot;Example Domain&quot;}</code></p>
<p><strong>Note:</strong> If a page loader matches the URL (see Page Loaders section), the loader&#39;s steps execute instead of the default navigation. The response will include <code>&quot;loader&quot;: &quot;loader name&quot;</code> when this happens.</p>
<h4>refresh</h4>
<p>Reloads the current page.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;refresh&quot;}
{&quot;action&quot;: &quot;refresh&quot;, &quot;wait_until&quot;: &quot;networkidle&quot;}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>wait_until</code> (optional, default <code>&quot;domcontentloaded&quot;</code>): Same options as <code>goto</code>.</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;url&quot;: &quot;https://example.com/current-page&quot;, &quot;title&quot;: &quot;Current Page&quot;}</code></p>
<h3>System Input (Undetectable)</h3>
<h4>system_click</h4>
<p>Moves the mouse to viewport coordinates with a human-like curve (random jitter, eased acceleration), then clicks. This is the primary way to click things stealthily.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;system_click&quot;, &quot;x&quot;: 500, &quot;y&quot;: 300}
{&quot;action&quot;: &quot;system_click&quot;, &quot;x&quot;: 500, &quot;y&quot;: 300, &quot;duration&quot;: 0.5}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>x</code>, <code>y</code> (required): Viewport coordinates ‚Äî get these from <code>get_interactive_elements</code>.</li>
<li><code>duration</code> (optional): How long the mouse movement takes in seconds. If omitted, a random duration between 0.2-0.6s is used for realism.</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;system_clicked&quot;: {&quot;x&quot;: 500, &quot;y&quot;: 300}}</code></p>
<p><strong>How it differs from <code>mouse_click</code>:</strong> <code>system_click</code> always moves the mouse first (smooth human-like path), then clicks. <code>mouse_click</code> can click at a position instantly without the smooth movement, or click wherever the mouse currently is.</p>
<h4>mouse_move</h4>
<p>Moves the mouse to viewport coordinates with human-like movement (jitter, eased curve) but does NOT click. Use this to hover over elements (to trigger hover menus, tooltips) or to simulate natural mouse behavior between actions.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;mouse_move&quot;, &quot;x&quot;: 500, &quot;y&quot;: 300}
{&quot;action&quot;: &quot;mouse_move&quot;, &quot;x&quot;: 500, &quot;y&quot;: 300, &quot;duration&quot;: 0.4}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>x</code>, <code>y</code> (required): Viewport coordinates.</li>
<li><code>duration</code> (optional): Movement time in seconds. Random 0.2-0.6s if omitted.</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;moved_to&quot;: {&quot;x&quot;: 500, &quot;y&quot;: 300}}</code></p>
<h4>mouse_click</h4>
<p>Clicks at a position or at the current mouse location. Unlike <code>system_click</code>, this does NOT do a smooth mouse movement first ‚Äî it&#39;s a direct click via PyAutoGUI.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;mouse_click&quot;}
{&quot;action&quot;: &quot;mouse_click&quot;, &quot;x&quot;: 500, &quot;y&quot;: 300}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>x</code>, <code>y</code> (optional): If provided, clicks at that viewport position directly. If omitted, clicks wherever the mouse currently is.</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;clicked_at&quot;: {&quot;x&quot;: 500, &quot;y&quot;: 300}}</code> or <code>{&quot;clicked_at&quot;: &quot;current&quot;}</code></p>
<p><strong>When to use:</strong> After a <code>mouse_move</code> when you want to separate the movement and click into two steps. Or when the mouse is already positioned and you just need to click.</p>
<h4>system_type</h4>
<p>Types text character-by-character via real OS keystrokes. Each keystroke has a randomized delay (jittered around the interval) to mimic human typing speed. Completely undetectable.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;system_type&quot;, &quot;text&quot;: &quot;hello world&quot;}
{&quot;action&quot;: &quot;system_type&quot;, &quot;text&quot;: &quot;hello world&quot;, &quot;interval&quot;: 0.12}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>text</code> (required): The text to type. Must click/focus an input field first.</li>
<li><code>interval</code> (optional, default <code>0.08</code>): Base delay between keystrokes in seconds. Actual delay is randomized +-30ms around this value.</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;typed_len&quot;: 11}</code></p>
<p><strong>Important:</strong> You must click on the input field first (using <code>system_click</code> or <code>click</code>) before calling <code>system_type</code>. This action types into whatever is currently focused.</p>
<h4>send_key</h4>
<p>Sends a single keyboard key or key combination via OS-level input. Use this for pressing Enter to submit forms, Tab to move between fields, Escape to close dialogs, or any key combos like Ctrl+A, Ctrl+C, etc.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;send_key&quot;, &quot;key&quot;: &quot;enter&quot;}
{&quot;action&quot;: &quot;send_key&quot;, &quot;key&quot;: &quot;tab&quot;}
{&quot;action&quot;: &quot;send_key&quot;, &quot;key&quot;: &quot;escape&quot;}
{&quot;action&quot;: &quot;send_key&quot;, &quot;key&quot;: &quot;ctrl+a&quot;}
{&quot;action&quot;: &quot;send_key&quot;, &quot;key&quot;: &quot;ctrl+shift+t&quot;}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>key</code> (required): Key name or combo with <code>+</code> separator. Key names follow PyAutoGUI naming: <code>enter</code>, <code>tab</code>, <code>escape</code>, <code>backspace</code>, <code>delete</code>, <code>up</code>, <code>down</code>, <code>left</code>, <code>right</code>, <code>home</code>, <code>end</code>, <code>pageup</code>, <code>pagedown</code>, <code>f1</code>-<code>f12</code>, <code>ctrl</code>, <code>alt</code>, <code>shift</code>, <code>space</code>, etc.</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;send_key&quot;: &quot;enter&quot;}</code></p>
<h4>scroll</h4>
<p>Scrolls the page using the mouse scroll wheel. Generates real OS-level scroll events.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;scroll&quot;, &quot;amount&quot;: -3}
{&quot;action&quot;: &quot;scroll&quot;, &quot;amount&quot;: 5, &quot;x&quot;: 500, &quot;y&quot;: 300}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>amount</code> (optional, default <code>-3</code>): Scroll amount. <strong>Negative = scroll down</strong>, positive = scroll up. Each unit is roughly one &quot;click&quot; of a mouse wheel.</li>
<li><code>x</code>, <code>y</code> (optional): If provided, moves the mouse to these viewport coordinates first, then scrolls. Useful for scrolling inside a specific scrollable element rather than the whole page.</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;scrolled&quot;: -3}</code></p>
<h3>Playwright Input (Detectable)</h3>
<p>These are faster and more convenient but use Playwright&#39;s DOM event injection, which is detectable by sophisticated behavioral analysis.</p>
<h4>click</h4>
<p>Clicks an element by CSS selector or XPath. Playwright finds the element in the DOM, scrolls it into view if needed, and dispatches click events.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;click&quot;, &quot;selector&quot;: &quot;#submit-btn&quot;}
{&quot;action&quot;: &quot;click&quot;, &quot;selector&quot;: &quot;button.primary&quot;}
{&quot;action&quot;: &quot;click&quot;, &quot;selector&quot;: &quot;xpath=//button[@id=&#39;submit-btn&#39;]&quot;}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>selector</code> (required): CSS selector or XPath (prefix with <code>xpath=</code>).</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;clicked&quot;: &quot;#submit-btn&quot;}</code></p>
<p><strong>When to use over system_click:</strong> When you have a selector but don&#39;t want to bother getting coordinates. When the element might move around and coordinates aren&#39;t reliable. When stealth isn&#39;t critical.</p>
<h4>fill</h4>
<p>Fills an input field by selector. Clears any existing content first, then sets the value. This is the fastest way to fill forms but is detectable because it doesn&#39;t generate individual keystroke events.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;fill&quot;, &quot;selector&quot;: &quot;input[name=&#39;email&#39;]&quot;, &quot;value&quot;: &quot;user@example.com&quot;}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>selector</code> (required): CSS selector or XPath of the input element.</li>
<li><code>value</code> (required): Text to fill in.</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;filled&quot;: &quot;input[name=&#39;email&#39;]&quot;}</code></p>
<h4>type</h4>
<p>Types text into an element character-by-character via Playwright (NOT the OS). Each keystroke has a configurable delay. This is a middle ground between <code>fill</code> (instant but obviously automated) and <code>system_type</code> (OS-level, undetectable). The typing pattern is more realistic than <code>fill</code> but still comes through Playwright&#39;s event system.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;type&quot;, &quot;selector&quot;: &quot;#search&quot;, &quot;text&quot;: &quot;query&quot;, &quot;delay&quot;: 0.05}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>selector</code> (required): CSS selector or XPath of the element.</li>
<li><code>text</code> (required): Text to type.</li>
<li><code>delay</code> (optional, default <code>0.05</code>): Delay between keystrokes in seconds.</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;typed&quot;: &quot;#search&quot;}</code></p>
<h3>Screenshots</h3>
<p>Screenshots are GET requests (not POST actions).</p>
<h4>GET /screenshot/browser</h4>
<p>Captures the browser viewport as a PNG image. This is what the page looks like to a user.</p>
<pre><code class="language-bash">curl -s &quot;$STEALTHY_AUTO_BROWSE_URL/screenshot/browser?whLargest=512&quot; -o screenshot.png
</code></pre>
<p><strong>Always resize screenshots</strong> to avoid huge images. Resize query parameters (all optional):</p>
<table>
<thead>
<tr>
<th>Parameter</th>
<th>What it does</th>
</tr>
</thead>
<tbody><tr>
<td><code>whLargest=512</code></td>
<td>Scales so the largest dimension is 512px, keeps aspect ratio. <strong>Use this by default.</strong></td>
</tr>
<tr>
<td><code>width=800</code></td>
<td>Scales to 800px wide, keeps aspect ratio</td>
</tr>
<tr>
<td><code>height=300</code></td>
<td>Scales to 300px tall, keeps aspect ratio</td>
</tr>
<tr>
<td><code>width=400&amp;height=400</code></td>
<td>Forces exact 400x400 dimensions</td>
</tr>
</tbody></table>
<h4>GET /screenshot/desktop</h4>
<p>Captures the entire virtual desktop (including window chrome, taskbar, etc.) using <code>scrot</code>. Same resize parameters as above. Useful when you need to see things outside the browser viewport.</p>
<pre><code class="language-bash">curl -s &quot;$STEALTHY_AUTO_BROWSE_URL/screenshot/desktop?whLargest=512&quot; -o desktop.png
</code></pre>
<h3>Page Inspection</h3>
<h4>get_interactive_elements</h4>
<p>Scans the page and returns every interactive element (buttons, links, inputs, selects, textareas, etc.) with their viewport coordinates. This is how you find what to click and where.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;get_interactive_elements&quot;}
{&quot;action&quot;: &quot;get_interactive_elements&quot;, &quot;visible_only&quot;: true}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>visible_only</code> (optional, default <code>true</code>): Only return elements that are currently visible on screen.</li>
</ul>
<p><strong>Response data:</strong></p>
<pre><code class="language-json">{
  &quot;count&quot;: 5,
  &quot;elements&quot;: [
    {
      &quot;i&quot;: 0,
      &quot;tag&quot;: &quot;button&quot;,
      &quot;id&quot;: &quot;submit-btn&quot;,
      &quot;text&quot;: &quot;Submit&quot;,
      &quot;selector&quot;: &quot;#submit-btn&quot;,
      &quot;x&quot;: 400,
      &quot;y&quot;: 250,
      &quot;w&quot;: 120,
      &quot;h&quot;: 40,
      &quot;visible&quot;: true
    },
    {
      &quot;i&quot;: 1,
      &quot;tag&quot;: &quot;input&quot;,
      &quot;id&quot;: null,
      &quot;text&quot;: &quot;&quot;,
      &quot;selector&quot;: &quot;input[name=&#39;email&#39;]&quot;,
      &quot;x&quot;: 300,
      &quot;y&quot;: 180,
      &quot;w&quot;: 250,
      &quot;h&quot;: 35,
      &quot;visible&quot;: true
    }
  ]
}
</code></pre>
<p>The <code>x</code>, <code>y</code> are the center of the element ‚Äî pass these directly to <code>system_click</code>. The <code>selector</code> can be used with Playwright actions like <code>click</code> or <code>fill</code>. The <code>w</code>, <code>h</code> give you the element dimensions.</p>
<p><strong>This is your primary tool for understanding what you can interact with on a page.</strong> Call this before clicking anything.</p>
<h4>get_text</h4>
<p>Returns all visible text content of the page body. Text is truncated to 10,000 characters.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;get_text&quot;}
</code></pre>
<p><strong>Response data:</strong> <code>{&quot;text&quot;: &quot;Page title\nSome content here...&quot;, &quot;length&quot;: 1234}</code></p>
<p>This is usually the first thing to call after navigating ‚Äî it tells you what&#39;s on the page without needing a screenshot.</p>
<h4>get_html</h4>
<p>Returns the full HTML source of the current page.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;get_html&quot;}
</code></pre>
<p><strong>Response data:</strong> <code>{&quot;html&quot;: &quot;&lt;!DOCTYPE html&gt;...&quot;, &quot;length&quot;: 45678}</code></p>
<p>Use when <code>get_text</code> doesn&#39;t give enough structure to understand the page layout, or when you need to find specific elements in the DOM.</p>
<h4>eval</h4>
<p>Executes arbitrary JavaScript in the page context and returns the result. The expression is evaluated via <code>page.evaluate()</code>.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;eval&quot;, &quot;expression&quot;: &quot;document.title&quot;}
{&quot;action&quot;: &quot;eval&quot;, &quot;expression&quot;: &quot;document.querySelectorAll(&#39;a&#39;).length&quot;}
{&quot;action&quot;: &quot;eval&quot;, &quot;expression&quot;: &quot;JSON.stringify(performance.timing)&quot;}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>expression</code> (required): JavaScript expression to evaluate. Must return a JSON-serializable value.</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;result&quot;: &quot;Example Domain&quot;}</code> ‚Äî the result is whatever the expression returns.</p>
<h3>Wait Conditions</h3>
<p>Use these instead of <code>sleep</code> to wait for page content. They&#39;re more reliable because they wait for the exact condition rather than an arbitrary time.</p>
<h4>wait_for_element</h4>
<p>Waits for an element matching a CSS selector or XPath to reach a certain state (visible, hidden, attached to DOM, detached).</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;wait_for_element&quot;, &quot;selector&quot;: &quot;#results&quot;, &quot;timeout&quot;: 10}
{&quot;action&quot;: &quot;wait_for_element&quot;, &quot;selector&quot;: &quot;xpath=//div[@class=&#39;loaded&#39;]&quot;, &quot;timeout&quot;: 15}
{&quot;action&quot;: &quot;wait_for_element&quot;, &quot;selector&quot;: &quot;.spinner&quot;, &quot;state&quot;: &quot;hidden&quot;, &quot;timeout&quot;: 10}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>selector</code> (required): CSS selector or XPath (prefix with <code>xpath=</code>).</li>
<li><code>state</code> (optional, default <code>&quot;visible&quot;</code>): What state to wait for. Options: <code>&quot;visible&quot;</code> (rendered and not hidden), <code>&quot;hidden&quot;</code> (not visible), <code>&quot;attached&quot;</code> (in DOM regardless of visibility), <code>&quot;detached&quot;</code> (removed from DOM).</li>
<li><code>timeout</code> (optional, default <code>30</code>): Max wait time in seconds. Throws error if exceeded.</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;selector&quot;: &quot;#results&quot;, &quot;state&quot;: &quot;visible&quot;}</code></p>
<h4>wait_for_text</h4>
<p>Waits for specific text to appear anywhere in the page body.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;wait_for_text&quot;, &quot;text&quot;: &quot;Search results&quot;, &quot;timeout&quot;: 10}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>text</code> (required): Exact text to look for (substring match on <code>document.body.innerText</code>).</li>
<li><code>timeout</code> (optional, default <code>30</code>): Max wait time in seconds.</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;text&quot;: &quot;Search results&quot;, &quot;found&quot;: true}</code></p>
<h4>wait_for_url</h4>
<p>Waits for the page URL to match a pattern. Useful after form submissions or redirects.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;wait_for_url&quot;, &quot;url&quot;: &quot;**/dashboard&quot;, &quot;timeout&quot;: 10}
{&quot;action&quot;: &quot;wait_for_url&quot;, &quot;url&quot;: &quot;https://example.com/success*&quot;, &quot;timeout&quot;: 15}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>url</code> (required): URL pattern to match. Supports <code>*</code> (any chars except <code>/</code>) and <code>**</code> (any chars including <code>/</code>) glob patterns. Can also be a full URL for exact match.</li>
<li><code>timeout</code> (optional, default <code>30</code>): Max wait time in seconds.</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;url&quot;: &quot;https://example.com/dashboard&quot;}</code></p>
<h4>wait_for_network_idle</h4>
<p>Waits until there are no network requests in flight for 500ms. Useful for pages that load content dynamically after the initial page load.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;wait_for_network_idle&quot;, &quot;timeout&quot;: 30}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>timeout</code> (optional, default <code>30</code>): Max wait time in seconds.</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;idle&quot;: true}</code></p>
<h3>Tab Management</h3>
<p>The browser can have multiple tabs open. One tab is &quot;active&quot; at a time ‚Äî all actions operate on the active tab.</p>
<h4>list_tabs</h4>
<p>Returns all open tabs with their URLs and which one is active.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;list_tabs&quot;}
</code></pre>
<p><strong>Response data:</strong></p>
<pre><code class="language-json">{
  &quot;count&quot;: 2,
  &quot;tabs&quot;: [
    {&quot;index&quot;: 0, &quot;url&quot;: &quot;https://example.com/&quot;, &quot;active&quot;: false},
    {&quot;index&quot;: 1, &quot;url&quot;: &quot;https://other.com/&quot;, &quot;active&quot;: true}
  ]
}
</code></pre>
<h4>new_tab</h4>
<p>Opens a new browser tab. Optionally navigates it to a URL. The new tab becomes the active tab.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;new_tab&quot;}
{&quot;action&quot;: &quot;new_tab&quot;, &quot;url&quot;: &quot;https://example.com&quot;}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>url</code> (optional): URL to navigate to in the new tab.</li>
<li><code>wait_until</code> (optional, default <code>&quot;domcontentloaded&quot;</code>): Same as <code>goto</code>.</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;index&quot;: 1, &quot;url&quot;: &quot;https://example.com/&quot;}</code></p>
<h4>switch_tab</h4>
<p>Switches the active tab by index (0-based). All subsequent actions will operate on this tab.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;switch_tab&quot;, &quot;index&quot;: 0}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>index</code> (required): Tab index from <code>list_tabs</code>.</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;index&quot;: 0, &quot;url&quot;: &quot;https://example.com/&quot;}</code></p>
<h4>close_tab</h4>
<p>Closes a tab. After closing, the last remaining tab becomes active.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;close_tab&quot;}
{&quot;action&quot;: &quot;close_tab&quot;, &quot;index&quot;: 1}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>index</code> (optional): Tab index to close. If omitted, closes the currently active tab.</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;closed&quot;: true, &quot;remaining&quot;: 1}</code></p>
<h3>Dialog Handling</h3>
<p>Browsers have modal dialogs (alert, confirm, prompt). By default, dialogs are auto-accepted (clicks OK). Use <code>handle_dialog</code> if you need to dismiss a dialog or provide text for a prompt.</p>
<h4>handle_dialog</h4>
<p><strong>Call BEFORE the action that triggers the dialog</strong> if you want to dismiss it or provide prompt text. If you don&#39;t call this, the dialog is auto-accepted (clicks OK).</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;handle_dialog&quot;, &quot;accept&quot;: true}
{&quot;action&quot;: &quot;handle_dialog&quot;, &quot;accept&quot;: false}
{&quot;action&quot;: &quot;handle_dialog&quot;, &quot;accept&quot;: true, &quot;text&quot;: &quot;my response&quot;}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>accept</code> (optional, default <code>true</code>): <code>true</code> clicks OK/Accept, <code>false</code> clicks Cancel/Dismiss.</li>
<li><code>text</code> (optional): Response text for prompt dialogs. Ignored for alert/confirm.</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;configured&quot;: {&quot;accept&quot;: true, &quot;text&quot;: null}}</code></p>
<p><strong>Example ‚Äî handling a confirm dialog:</strong></p>
<pre><code class="language-bash"># Step 1: Tell the browser to accept the next dialog
curl -X POST $API -H &#39;Content-Type: application/json&#39; -d &#39;{&quot;action&quot;: &quot;handle_dialog&quot;, &quot;accept&quot;: true}&#39;
# Step 2: Now click the button that triggers the confirm
curl -X POST $API -H &#39;Content-Type: application/json&#39; -d &#39;{&quot;action&quot;: &quot;system_click&quot;, &quot;x&quot;: 300, &quot;y&quot;: 200}&#39;
</code></pre>
<h4>get_last_dialog</h4>
<p>Returns information about the most recent dialog that appeared.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;get_last_dialog&quot;}
</code></pre>
<p><strong>Response data:</strong></p>
<pre><code class="language-json">{
  &quot;dialog&quot;: {
    &quot;type&quot;: &quot;confirm&quot;,
    &quot;message&quot;: &quot;Are you sure you want to delete this?&quot;,
    &quot;default_value&quot;: &quot;&quot;,
    &quot;buttons&quot;: [&quot;ok&quot;, &quot;cancel&quot;]
  }
}
</code></pre>
<p>Returns <code>{&quot;dialog&quot;: null}</code> if no dialog has appeared yet. The <code>type</code> field is one of: <code>&quot;alert&quot;</code>, <code>&quot;confirm&quot;</code>, <code>&quot;prompt&quot;</code>, <code>&quot;beforeunload&quot;</code>.</p>
<h3>Cookies</h3>
<h4>get_cookies</h4>
<p>Returns all cookies for the browser context, or cookies for specific URLs.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;get_cookies&quot;}
{&quot;action&quot;: &quot;get_cookies&quot;, &quot;urls&quot;: [&quot;https://example.com&quot;]}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>urls</code> (optional): Array of URLs to filter cookies by. If omitted, returns all cookies.</li>
</ul>
<p><strong>Response data:</strong></p>
<pre><code class="language-json">{
  &quot;count&quot;: 3,
  &quot;cookies&quot;: [
    {&quot;name&quot;: &quot;session&quot;, &quot;value&quot;: &quot;abc123&quot;, &quot;domain&quot;: &quot;.example.com&quot;, &quot;path&quot;: &quot;/&quot;, &quot;httpOnly&quot;: true, &quot;secure&quot;: true, ...}
  ]
}
</code></pre>
<h4>set_cookie</h4>
<p>Sets a cookie in the browser context.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;set_cookie&quot;, &quot;name&quot;: &quot;session&quot;, &quot;value&quot;: &quot;abc123&quot;, &quot;url&quot;: &quot;https://example.com&quot;}
{&quot;action&quot;: &quot;set_cookie&quot;, &quot;name&quot;: &quot;pref&quot;, &quot;value&quot;: &quot;dark&quot;, &quot;domain&quot;: &quot;.example.com&quot;, &quot;path&quot;: &quot;/&quot;, &quot;httpOnly&quot;: false, &quot;secure&quot;: true}
</code></pre>
<p><strong>Parameters:</strong> Any standard cookie fields ‚Äî <code>name</code>, <code>value</code>, <code>url</code>, <code>domain</code>, <code>path</code>, <code>httpOnly</code>, <code>secure</code>, <code>sameSite</code>, <code>expires</code>. At minimum you need <code>name</code>, <code>value</code>, and either <code>url</code> or <code>domain</code>.</p>
<p><strong>Response data:</strong> <code>{&quot;set&quot;: &quot;session&quot;}</code></p>
<h4>delete_cookies</h4>
<p>Clears all cookies from the browser context.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;delete_cookies&quot;}
</code></pre>
<p><strong>Response data:</strong> <code>{&quot;cleared&quot;: true}</code></p>
<h3>Storage</h3>
<p>Access the page&#39;s localStorage and sessionStorage. These are per-origin ‚Äî you must be on the right page for the storage to be accessible.</p>
<h4>get_storage</h4>
<p>Returns all items from localStorage or sessionStorage as a key-value object.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;get_storage&quot;, &quot;type&quot;: &quot;local&quot;}
{&quot;action&quot;: &quot;get_storage&quot;, &quot;type&quot;: &quot;session&quot;}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>type</code> (optional, default <code>&quot;local&quot;</code>): <code>&quot;local&quot;</code> for localStorage, <code>&quot;session&quot;</code> for sessionStorage.</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;items&quot;: {&quot;theme&quot;: &quot;dark&quot;, &quot;lang&quot;: &quot;en&quot;}, &quot;type&quot;: &quot;local&quot;}</code></p>
<h4>set_storage</h4>
<p>Sets a single key-value pair in localStorage or sessionStorage.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;set_storage&quot;, &quot;type&quot;: &quot;local&quot;, &quot;key&quot;: &quot;theme&quot;, &quot;value&quot;: &quot;dark&quot;}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>type</code> (optional, default <code>&quot;local&quot;</code>): <code>&quot;local&quot;</code> or <code>&quot;session&quot;</code>.</li>
<li><code>key</code> (required): Storage key.</li>
<li><code>value</code> (required): Storage value (string).</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;set&quot;: &quot;theme&quot;, &quot;type&quot;: &quot;local&quot;}</code></p>
<h4>clear_storage</h4>
<p>Clears all items from localStorage or sessionStorage.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;clear_storage&quot;, &quot;type&quot;: &quot;local&quot;}
{&quot;action&quot;: &quot;clear_storage&quot;, &quot;type&quot;: &quot;session&quot;}
</code></pre>
<p><strong>Response data:</strong> <code>{&quot;cleared&quot;: &quot;local&quot;}</code></p>
<h3>Downloads</h3>
<p>The browser automatically tracks file downloads triggered by page interactions (clicking download links, form submissions that return files, etc.).</p>
<h4>get_last_download</h4>
<p>Returns information about the most recently downloaded file.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;get_last_download&quot;}
</code></pre>
<p><strong>Response data:</strong></p>
<pre><code class="language-json">{
  &quot;download&quot;: {
    &quot;url&quot;: &quot;https://example.com/file.pdf&quot;,
    &quot;filename&quot;: &quot;file.pdf&quot;,
    &quot;path&quot;: &quot;/tmp/playwright-downloads/abc123/file.pdf&quot;
  }
}
</code></pre>
<p>Returns <code>{&quot;download&quot;: null}</code> if nothing has been downloaded yet. The <code>path</code> is the local path inside the container where the file was saved. The <code>filename</code> is what the server suggested as the download name.</p>
<h3>Uploads</h3>
<h4>upload_file</h4>
<p>Programmatically sets a file on an <code>&lt;input type=&quot;file&quot;&gt;</code> element without opening the OS file picker. The file must exist inside the container ‚Äî use <code>docker cp</code> to copy files in if needed.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;upload_file&quot;, &quot;selector&quot;: &quot;#file-input&quot;, &quot;file_path&quot;: &quot;/tmp/document.pdf&quot;}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>selector</code> (required): CSS selector of the file input element.</li>
<li><code>file_path</code> (required): Absolute path to the file inside the container.</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;selector&quot;: &quot;#file-input&quot;, &quot;file&quot;: &quot;document.pdf&quot;, &quot;size&quot;: 12345}</code></p>
<p><strong>Note:</strong> After setting the file, you still need to submit the form (click the submit button) for the upload to actually happen.</p>
<h3>Network Logging</h3>
<p>Capture all HTTP requests and responses the page makes. Useful for debugging, finding API endpoints the page calls, or verifying that certain resources loaded.</p>
<h4>enable_network_log</h4>
<p>Starts recording all HTTP requests and responses from the active page.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;enable_network_log&quot;}
</code></pre>
<p><strong>Response data:</strong> <code>{&quot;enabled&quot;: true}</code></p>
<h4>disable_network_log</h4>
<p>Stops recording network activity. Already-captured entries remain.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;disable_network_log&quot;}
</code></pre>
<p><strong>Response data:</strong> <code>{&quot;enabled&quot;: false}</code></p>
<h4>get_network_log</h4>
<p>Returns all captured network entries since logging was enabled (or last cleared).</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;get_network_log&quot;}
</code></pre>
<p><strong>Response data:</strong></p>
<pre><code class="language-json">{
  &quot;count&quot;: 4,
  &quot;log&quot;: [
    {&quot;type&quot;: &quot;request&quot;, &quot;url&quot;: &quot;https://api.example.com/data&quot;, &quot;method&quot;: &quot;GET&quot;, &quot;resource_type&quot;: &quot;fetch&quot;, &quot;timestamp&quot;: 1234567890.123},
    {&quot;type&quot;: &quot;response&quot;, &quot;url&quot;: &quot;https://api.example.com/data&quot;, &quot;status&quot;: 200, &quot;timestamp&quot;: 1234567890.456},
    {&quot;type&quot;: &quot;request&quot;, &quot;url&quot;: &quot;https://cdn.example.com/style.css&quot;, &quot;method&quot;: &quot;GET&quot;, &quot;resource_type&quot;: &quot;stylesheet&quot;, &quot;timestamp&quot;: 1234567890.789},
    {&quot;type&quot;: &quot;response&quot;, &quot;url&quot;: &quot;https://cdn.example.com/style.css&quot;, &quot;status&quot;: 200, &quot;timestamp&quot;: 1234567890.999}
  ]
}
</code></pre>
<p>Each entry is either a <code>&quot;request&quot;</code> or <code>&quot;response&quot;</code>. Requests include <code>method</code> and <code>resource_type</code> (fetch, document, stylesheet, script, image, etc.). Responses include <code>status</code> code.</p>
<h4>clear_network_log</h4>
<p>Deletes all captured network entries but keeps logging enabled if it was on.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;clear_network_log&quot;}
</code></pre>
<p><strong>Response data:</strong> <code>{&quot;cleared&quot;: true}</code></p>
<h3>Scrolling</h3>
<h4>scroll_to_bottom</h4>
<p>Scrolls the entire page from top to bottom using JavaScript <code>window.scrollBy()</code>. Scrolls one viewport height at a time with a fixed delay between scrolls. When it reaches the bottom (scroll position stops changing), it scrolls back to the top. Useful for triggering lazy-loaded content.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;scroll_to_bottom&quot;}
{&quot;action&quot;: &quot;scroll_to_bottom&quot;, &quot;delay&quot;: 0.6}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>delay</code> (optional, default <code>0.4</code>): Seconds to wait between each scroll step.</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;scrolled&quot;: &quot;bottom&quot;}</code></p>
<h4>scroll_to_bottom_humanized</h4>
<p>Same as <code>scroll_to_bottom</code> but uses real OS-level mouse wheel scrolling (via PyAutoGUI) with randomized scroll amounts and jittered delays to look like a human scrolling. Undetectable by behavioral analysis.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;scroll_to_bottom_humanized&quot;}
{&quot;action&quot;: &quot;scroll_to_bottom_humanized&quot;, &quot;min_clicks&quot;: 3, &quot;max_clicks&quot;: 8, &quot;delay&quot;: 0.7}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>min_clicks</code> (optional, default <code>2</code>): Minimum mouse wheel clicks per scroll step.</li>
<li><code>max_clicks</code> (optional, default <code>6</code>): Maximum mouse wheel clicks per scroll step. A random value between min and max is chosen each time.</li>
<li><code>delay</code> (optional, default <code>0.5</code>): Base delay between scroll steps. Actual delay is jittered +-30%.</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;scrolled&quot;: &quot;bottom_humanized&quot;}</code></p>
<h3>Display</h3>
<h4>calibrate</h4>
<p>Recalculates the mapping between viewport coordinates (what <code>get_interactive_elements</code> returns) and screen coordinates (what PyAutoGUI uses). The browser has window chrome (title bar, address bar) that offsets the viewport from the screen origin.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;calibrate&quot;}
</code></pre>
<p><strong>Response data:</strong> <code>{&quot;window_offset&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 74}}</code></p>
<p><strong>When to call this:</strong> After entering/exiting fullscreen, after the browser window is resized, or if <code>system_click</code> coordinates seem off. The offset is auto-calculated at startup, so you rarely need this.</p>
<h4>get_resolution</h4>
<p>Returns the virtual display resolution (from the XVFB_RESOLUTION environment variable).</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;get_resolution&quot;}
</code></pre>
<p><strong>Response data:</strong> <code>{&quot;width&quot;: 1920, &quot;height&quot;: 1080}</code></p>
<h4>enter_fullscreen / exit_fullscreen</h4>
<p>Toggles browser fullscreen mode (hides address bar and window chrome). In fullscreen, the viewport takes up the entire screen, so coordinates map differently.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;enter_fullscreen&quot;}
{&quot;action&quot;: &quot;exit_fullscreen&quot;}
</code></pre>
<p><strong>Response data:</strong> <code>{&quot;fullscreen&quot;: true, &quot;changed&quot;: true}</code> ‚Äî <code>changed</code> is <code>false</code> if already in the requested state.</p>
<p><strong>Important:</strong> Call <code>calibrate</code> after entering/exiting fullscreen to update the coordinate mapping.</p>
<h3>Utility</h3>
<h4>ping</h4>
<p>Health check that returns the current page URL. Use to verify the API is responding and the browser is alive.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;ping&quot;}
</code></pre>
<p><strong>Response data:</strong> <code>{&quot;message&quot;: &quot;pong&quot;, &quot;url&quot;: &quot;https://example.com/&quot;}</code></p>
<h4>sleep</h4>
<p>Pauses execution for a specified duration. Prefer <code>wait_for_element</code> or <code>wait_for_text</code> when waiting for page content ‚Äî use <code>sleep</code> only for fixed timing needs.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;sleep&quot;, &quot;duration&quot;: 2}
</code></pre>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>duration</code> (optional, default <code>1</code>): Seconds to sleep.</li>
</ul>
<p><strong>Response data:</strong> <code>{&quot;slept&quot;: 2}</code></p>
<h4>close</h4>
<p>Shuts down the browser. The container will stop after this.</p>
<pre><code class="language-json">{&quot;action&quot;: &quot;close&quot;}
</code></pre>
<p><strong>Response data:</strong> <code>{&quot;message&quot;: &quot;closing&quot;}</code></p>
<h3>State Endpoints (GET)</h3>
<h4>GET /state</h4>
<p>Returns the current browser state.</p>
<pre><code class="language-bash">curl -s &quot;$STEALTHY_AUTO_BROWSE_URL/state&quot;
</code></pre>
<p><strong>Response:</strong></p>
<pre><code class="language-json">{
  &quot;status&quot;: &quot;ready&quot;,
  &quot;url&quot;: &quot;https://example.com/&quot;,
  &quot;title&quot;: &quot;Example Domain&quot;,
  &quot;window_offset&quot;: {&quot;x&quot;: 0, &quot;y&quot;: 74}
}
</code></pre>
<h4>GET /health</h4>
<p>Simple health check. Returns <code>ok</code> as plain text when the API is ready.</p>
<pre><code class="language-bash">curl -s &quot;$STEALTHY_AUTO_BROWSE_URL/health&quot;
</code></pre>
<h2>Container Options</h2>
<pre><code class="language-bash"># Custom display resolution
docker run -d -p 8080:8080 -e XVFB_RESOLUTION=1280x720 psyb0t/stealthy-auto-browse

# Match timezone to your IP&#39;s geographic location (important for stealth ‚Äî mismatched
# timezone is a common bot detection signal)
docker run -d -p 8080:8080 -e TZ=Europe/Bucharest psyb0t/stealthy-auto-browse

# Route browser traffic through an HTTP proxy
docker run -d -p 8080:8080 -e PROXY_URL=http://user:pass@proxy:8888 psyb0t/stealthy-auto-browse

# Persistent browser profile ‚Äî cookies, sessions, and fingerprint survive container restarts
docker run -d -p 8080:8080 -v ./profile:/userdata psyb0t/stealthy-auto-browse

# Open a URL automatically on startup
docker run -d -p 8080:8080 psyb0t/stealthy-auto-browse https://example.com
</code></pre>
<h2>Page Loaders (URL-Triggered Automation)</h2>
<p>Page loaders are like <strong>Greasemonkey/Tampermonkey userscripts</strong> but for the HTTP API. You define a set of actions that automatically run whenever the browser navigates to a matching URL. Instead of manually sending a sequence of commands every time you visit a site, you write it once as a YAML file and the container handles it.</p>
<p>This is useful for things like: removing cookie popups, dismissing overlays, waiting for dynamic content, cleaning up pages before scraping, or any repetitive setup you&#39;d otherwise do manually every time.</p>
<h3>How They Work</h3>
<ol>
<li>You create YAML files that define URL patterns and a list of steps</li>
<li>Mount those files into the container at <code>/loaders</code></li>
<li>Whenever <code>goto</code> navigates to a URL that matches a loader&#39;s pattern, the loader&#39;s steps run automatically instead of the default navigation</li>
</ol>
<p><strong>The steps are the exact same actions as the HTTP API.</strong> Every action you can send via <code>POST /</code> (goto, eval, click, system_click, sleep, scroll, wait_for_element, etc.) works as a loader step. Same names, same parameters.</p>
<h3>Setup</h3>
<pre><code class="language-bash">docker run -d -p 8080:8080 -p 5900:5900 \
  -v ./my-loaders:/loaders \
  psyb0t/stealthy-auto-browse
</code></pre>
<h3>Loader Format</h3>
<pre><code class="language-yaml">name: Human-readable name for this loader
match:
  domain: example.com         # Exact hostname match (www. is stripped automatically)
  path_prefix: /articles      # URL path must start with this
  regex: &quot;article/\\d+&quot;       # Full URL must match this regex
steps:
  - action: goto              # Same actions as the HTTP API
    url: &quot;${url}&quot;             # ${url} is replaced with the original URL
    wait_until: networkidle
  - action: eval
    expression: &quot;document.querySelector(&#39;.cookie-banner&#39;)?.remove()&quot;
  - action: wait_for_element
    selector: &quot;#main-content&quot;
    timeout: 10
</code></pre>
<h3>Match Rules</h3>
<p>All match fields are <strong>optional</strong>, but at least one is required. If you specify multiple fields, <strong>all</strong> of them must match for the loader to trigger:</p>
<ul>
<li><strong><code>domain</code></strong>: Exact hostname. <code>www.</code> is stripped from both sides before comparing, so <code>domain: example.com</code> matches <code>www.example.com</code> too.</li>
<li><strong><code>path_prefix</code></strong>: The URL path must start with this string. <code>path_prefix: /blog</code> matches <code>/blog</code>, <code>/blog/post-1</code>, <code>/blog/archive</code>, etc.</li>
<li><strong><code>regex</code></strong>: The full URL is tested against this regular expression.</li>
</ul>
<h3>The <code>${url}</code> Placeholder</h3>
<p>In any string value within a step, <code>${url}</code> is replaced with the original URL that was passed to <code>goto</code>. This lets you navigate to the URL with custom wait settings, or pass it to JavaScript:</p>
<pre><code class="language-yaml">steps:
  - action: goto
    url: &quot;${url}&quot;
    wait_until: networkidle
  - action: eval
    expression: &quot;console.log(&#39;Loaded:&#39;, &#39;${url}&#39;)&quot;
</code></pre>
<h3>Practical Example: Clean Scraping</h3>
<p>Say you&#39;re scraping a news site that has cookie popups, newsletter modals, and lazy-loaded content. Without a loader, you&#39;d send 5+ commands after every <code>goto</code>. With a loader:</p>
<pre><code class="language-yaml"># loaders/news_site.yaml
name: News Site Cleanup
match:
  domain: news-site.com
steps:
  # Navigate with full network wait so everything loads
  - action: goto
    url: &quot;${url}&quot;
    wait_until: networkidle

  # Wait for the main content to be there
  - action: wait_for_element
    selector: &quot;article&quot;
    timeout: 10

  # Kill the cookie popup
  - action: eval
    expression: &quot;document.querySelector(&#39;.cookie-consent&#39;)?.remove()&quot;

  # Kill the newsletter modal
  - action: eval
    expression: &quot;document.querySelector(&#39;.newsletter-overlay&#39;)?.remove()&quot;

  # Scroll to trigger lazy-loaded images
  - action: scroll_to_bottom
    delay: 0.3

  # Small pause for everything to settle
  - action: sleep
    duration: 1
</code></pre>
<p>Now when you <code>goto</code> any URL on <code>news-site.com</code>, all of this happens automatically. Your response includes <code>&quot;loader&quot;: &quot;News Site Cleanup&quot;</code> so you know it triggered.</p>
<h3>Response When a Loader Triggers</h3>
<pre><code class="language-json">{
  &quot;success&quot;: true,
  &quot;data&quot;: {
    &quot;loader&quot;: &quot;News Site Cleanup&quot;,
    &quot;steps_executed&quot;: 6,
    &quot;last_result&quot;: { &quot;success&quot;: true, &quot;timestamp&quot;: 1234567890.456, &quot;data&quot;: { &quot;slept&quot;: 1 } }
  }
}
</code></pre>
<h2>Pre-installed Extensions</h2>
<p>The browser comes with these extensions pre-installed:</p>
<ul>
<li><strong>uBlock Origin</strong>: Ad and tracker blocking</li>
<li><strong>LocalCDN</strong>: Serves common CDN resources locally to prevent tracking</li>
<li><strong>ClearURLs</strong>: Strips tracking parameters from URLs</li>
<li><strong>Consent-O-Matic</strong>: Automatically handles cookie consent popups (clicks &quot;reject all&quot; or minimal consent)</li>
</ul>
<h2>Example: Full Login Flow (Undetectable)</h2>
<pre><code class="language-bash">API=$STEALTHY_AUTO_BROWSE_URL

# Navigate to login page
curl -s -X POST $API -H &#39;Content-Type: application/json&#39; \
  -d &#39;{&quot;action&quot;: &quot;goto&quot;, &quot;url&quot;: &quot;https://example.com/login&quot;}&#39;

# See what&#39;s on the page
curl -s -X POST $API -H &#39;Content-Type: application/json&#39; \
  -d &#39;{&quot;action&quot;: &quot;get_text&quot;}&#39;

# Find all interactive elements and their coordinates
curl -s -X POST $API -H &#39;Content-Type: application/json&#39; \
  -d &#39;{&quot;action&quot;: &quot;get_interactive_elements&quot;}&#39;

# Click the email field (coordinates from get_interactive_elements)
curl -s -X POST $API -H &#39;Content-Type: application/json&#39; \
  -d &#39;{&quot;action&quot;: &quot;system_click&quot;, &quot;x&quot;: 400, &quot;y&quot;: 200}&#39;

# Type email with human-like keystrokes
curl -s -X POST $API -H &#39;Content-Type: application/json&#39; \
  -d &#39;{&quot;action&quot;: &quot;system_type&quot;, &quot;text&quot;: &quot;user@example.com&quot;}&#39;

# Tab to password field
curl -s -X POST $API -H &#39;Content-Type: application/json&#39; \
  -d &#39;{&quot;action&quot;: &quot;send_key&quot;, &quot;key&quot;: &quot;tab&quot;}&#39;

# Type password
curl -s -X POST $API -H &#39;Content-Type: application/json&#39; \
  -d &#39;{&quot;action&quot;: &quot;system_type&quot;, &quot;text&quot;: &quot;secretpassword&quot;}&#39;

# Press Enter to submit
curl -s -X POST $API -H &#39;Content-Type: application/json&#39; \
  -d &#39;{&quot;action&quot;: &quot;send_key&quot;, &quot;key&quot;: &quot;enter&quot;}&#39;

# Wait for redirect to dashboard
curl -s -X POST $API -H &#39;Content-Type: application/json&#39; \
  -d &#39;{&quot;action&quot;: &quot;wait_for_url&quot;, &quot;url&quot;: &quot;**/dashboard&quot;, &quot;timeout&quot;: 15}&#39;

# Verify we&#39;re logged in
curl -s -X POST $API -H &#39;Content-Type: application/json&#39; \
  -d &#39;{&quot;action&quot;: &quot;get_text&quot;}&#39;
</code></pre>
<h2>Tips</h2>
<ol>
<li><strong>Always call <code>get_interactive_elements</code> before clicking</strong> ‚Äî don&#39;t guess coordinates</li>
<li><strong>Use system methods for stealth</strong> ‚Äî <code>system_click</code>, <code>system_type</code>, <code>send_key</code> are undetectable</li>
<li><strong>Use <code>get_text</code> first, screenshots second</strong> ‚Äî text is faster and smaller</li>
<li><strong>Match TZ to your IP location</strong> ‚Äî timezone mismatch is a common bot detection signal</li>
<li><strong>Resize screenshots with <code>?whLargest=512</code></strong> ‚Äî full resolution is unnecessarily large</li>
<li><strong>Mount <code>/userdata</code></strong> for persistent sessions ‚Äî cookies, fingerprint, and profile survive restarts</li>
<li><strong>Use wait conditions instead of <code>sleep</code></strong> ‚Äî <code>wait_for_element</code>, <code>wait_for_text</code>, <code>wait_for_url</code></li>
<li><strong>Call <code>handle_dialog</code> BEFORE the action that triggers it</strong> ‚Äî if you need to dismiss or provide prompt text (dialogs are auto-accepted otherwise)</li>
<li><strong>Call <code>calibrate</code> after fullscreen changes</strong> ‚Äî coordinate mapping shifts</li>
<li><strong>Add slight delays between actions for realism</strong> ‚Äî <code>sleep</code> with 0.5-1.5s between clicks looks more human</li>
</ol>

                </div>
              </div>
            </article>
            <aside class="skill-page-sidebar">
              <div class="sidebar-card">
                <div class="sidebar-title">Actions</div>
                <a href="https://github.com/openclaw/skills/tree/main/skills/psyb0t/stealthy-auto-browse/SKILL.md" target="_blank" rel="noopener" class="sidebar-btn sidebar-btn-primary">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"/></svg>
                  View on GitHub
                </a>
                <a href="https://clawdhub.com/psyb0t/stealthy-auto-browse" target="_blank" rel="noopener" class="sidebar-btn sidebar-btn-clawdhub">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/><line x1="2" y1="12" x2="22" y2="12"/></svg>
                  View on ClawdHub
                </a>
                <a href="https://raw.githubusercontent.com/openclaw/skills/main/skills/psyb0t/stealthy-auto-browse/SKILL.md" download="SKILL.md" class="sidebar-btn sidebar-btn-secondary">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                  Download SKILL.md
                </a>
                <button onclick="sendToSecurityAuditor()" class="sidebar-btn sidebar-btn-security">
                  <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/></svg>
                  Security Check
                </button>
              </div>
              <div class="sidebar-card">
                <div class="sidebar-title">Details</div>
                <div class="sidebar-info">
                  <div class="sidebar-info-item">
                    <span class="sidebar-info-label">Author</span>
                    <span class="sidebar-info-value">@psyb0t</span>
                  </div>
                  <div class="sidebar-info-item">
                    <span class="sidebar-info-label">Category</span>
                    <span class="sidebar-info-value">Browser & Automation</span>
                  </div>
                </div>
              </div>
            </aside>
          </div>
        
  <footer class="footer">
    <div class="footer-inner">
      <p class="footer-text" style="margin-bottom: 8px;"><a href="https://github.com/neonone123/moltdirectory" target="_blank" rel="noopener" style="color: var(--accent); text-decoration: none;">View on GitHub</a></p>
      <p class="footer-text" style="opacity: 0.6; font-size: 13px;">OpenClawDirectory.com is a community-run project and is not affiliated with the official OpenClaw team or Peter Steinberger. We are just fans of the lobster.</p>
    </div>
  </footer>
  <script>
    function toggleTheme() {
      const html = document.documentElement;
      const currentTheme = html.getAttribute('data-theme');
      const newTheme = currentTheme === 'light' ? 'dark' : 'light';
      if (newTheme === 'light') {
        html.setAttribute('data-theme', 'light');
      } else {
        html.removeAttribute('data-theme');
      }
      localStorage.setItem('theme', newTheme);
    }
    
    function copySkillContent(btn) {
      const wrapper = btn.closest('.skill-source-wrapper');
      const content = wrapper.querySelector('.markdown-content');
      if (content) {
        const text = content.innerText || content.textContent;
        navigator.clipboard.writeText(text).then(() => {
          btn.classList.add('copied');
          btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg> Copied!';
          setTimeout(() => {
            btn.classList.remove('copied');
            btn.innerHTML = '<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"/><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"/></svg> Copy';
          }, 2000);
        });
      }
    }

    async function sendToSecurityAuditor() {
      try {
        const contentElement = document.querySelector('.markdown-content');
        if (!contentElement) throw new Error('Could not find markdown content');
        const skillContent = contentElement.innerText || contentElement.textContent;
        localStorage.setItem('skillAuditContent', skillContent);
        window.open('/security-auditor', '_blank'); 
      } catch (error) {
        alert('Error: ' + error.message);
      }
    }

    function updateVoteWidget(widget, toolData) {
      if (!widget || !toolData) return;
      const upBtn = widget.querySelector('[data-vote="1"]');
      const downBtn = widget.querySelector('[data-vote="-1"]');
      const countNode = widget.querySelector('.vote-count');
      widget.dataset.rankScore = String(toolData.rankScore ?? 0);
      widget.dataset.viewerVote = String(toolData.viewerVote ?? 0);

      if (countNode) {
        countNode.textContent = toolData.displayCount || 'New';
      }
      if (upBtn) {
        upBtn.classList.toggle('is-active', Number(toolData.viewerVote) === 1);
      }
      if (downBtn) {
        downBtn.classList.toggle('is-active', Number(toolData.viewerVote) === -1);
      }
    }

    function setWidgetBusy(widget, busy) {
      widget.dataset.busy = busy ? '1' : '0';
      widget.querySelectorAll('.vote-btn').forEach((btn) => {
        btn.disabled = busy;
      });
    }

    function applySortMode(grid, mode) {
      const cards = [...grid.querySelectorAll('.skill-card[data-tool-id]')];
      cards.sort((a, b) => {
        if (mode === 'community') {
          const scoreDiff = Number(b.dataset.rankScore || 0) - Number(a.dataset.rankScore || 0);
          if (scoreDiff !== 0) return scoreDiff;
        }
        return Number(a.dataset.originalIndex || 0) - Number(b.dataset.originalIndex || 0);
      });
      cards.forEach((card) => grid.appendChild(card));
    }

    function bindSortToggle(toolbar, grid) {
      const buttons = toolbar.querySelectorAll('.sort-toggle-btn');
      const status = toolbar.querySelector('.sort-status');
      buttons.forEach((btn) => {
        btn.addEventListener('click', () => {
          const mode = btn.dataset.sortMode;
          buttons.forEach((b) => b.classList.toggle('is-active', b === btn));
          applySortMode(grid, mode);
          status.textContent = mode === 'community' ? 'Community ranking active' : 'Original order active';
        });
      });
    }

    async function fetchScores(categoryId, toolIds) {
      const params = new URLSearchParams({
        categoryId,
        toolIds: toolIds.join(',')
      });
      const response = await fetch('/api/v1/scores?' + params.toString(), {
        method: 'GET',
        credentials: 'same-origin'
      });
      if (!response.ok) {
        throw new Error('Unable to fetch vote scores');
      }
      return response.json();
    }

    async function submitVote(widget, voteValue) {
      const categoryId = widget.dataset.categoryId;
      const toolId = widget.dataset.toolId;
      setWidgetBusy(widget, true);
      try {
        const response = await fetch('/api/v1/vote', {
          method: 'POST',
          credentials: 'same-origin',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            categoryId,
            toolId,
            vote: voteValue
          })
        });
        const payload = await response.json().catch(() => ({}));
        if (!response.ok) {
          throw new Error(payload.error || 'Vote request failed');
        }
        if (payload.tool) {
          updateVoteWidget(widget, payload.tool);
          const card = widget.closest('.skill-card[data-tool-id]');
          if (card) {
            card.dataset.rankScore = String(payload.tool.rankScore ?? 0);
          }
        }
      } catch (error) {
        console.error(error);
      } finally {
        setWidgetBusy(widget, false);
      }
    }

    document.addEventListener('DOMContentLoaded', async () => {
      const widgets = [...document.querySelectorAll('.vote-widget[data-category-id][data-tool-id]')];
      if (widgets.length === 0) return;

      const grouped = new Map();
      widgets.forEach((widget) => {
        const key = widget.dataset.categoryId;
        if (!grouped.has(key)) grouped.set(key, new Map());
        grouped.get(key).set(widget.dataset.toolId, widget);
      });

      for (const [categoryId, widgetMap] of grouped.entries()) {
        const toolIds = [...widgetMap.keys()];
        try {
          const data = await fetchScores(categoryId, toolIds);
          const byTool = new Map((data.tools || []).map((tool) => [tool.toolId, tool]));
          for (const [toolId, widget] of widgetMap.entries()) {
            const toolData = byTool.get(toolId);
            if (toolData) {
              updateVoteWidget(widget, toolData);
              const card = widget.closest('.skill-card[data-tool-id]');
              if (card) {
                card.dataset.rankScore = String(toolData.rankScore ?? 0);
              }
            }
          }
        } catch (error) {
          console.error(error);
        }
      }

      widgets.forEach((widget) => {
        widget.querySelectorAll('.vote-btn').forEach((btn) => {
          btn.addEventListener('click', (event) => {
            event.preventDefault();
            event.stopPropagation();
            if (widget.dataset.busy === '1') return;
            const voteValue = Number(btn.dataset.vote);
            submitVote(widget, voteValue).then(() => {
              const grid = widget.closest('.skills-grid[data-category-id]');
              const toolbar = document.querySelector('.sort-toolbar[data-category-id="' + widget.dataset.categoryId + '"]');
              const communityBtn = toolbar ? toolbar.querySelector('.sort-toggle-btn[data-sort-mode="community"]') : null;
              if (grid && communityBtn && communityBtn.classList.contains('is-active')) {
                applySortMode(grid, 'community');
              }
            });
          });
        });
      });

      document.querySelectorAll('.skills-grid[data-category-id]').forEach((grid) => {
        const categoryId = grid.dataset.categoryId;
        const toolbar = document.querySelector('.sort-toolbar[data-category-id="' + categoryId + '"]');
        if (!toolbar) return;
        bindSortToggle(toolbar, grid);
        applySortMode(grid, 'community');
      });
    });
  </script>
</body>
</html>